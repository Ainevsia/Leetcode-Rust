<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>代码随想录算法训练营刷题笔记</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="day1.html"><strong aria-hidden="true">1.</strong> Day 1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day1/lc704.html"><strong aria-hidden="true">1.1.</strong> 704. 二分查找</a></li><li class="chapter-item expanded "><a href="day1/lc27.html"><strong aria-hidden="true">1.2.</strong> 27. 移除元素</a></li></ol></li><li class="chapter-item expanded "><a href="day2.html"><strong aria-hidden="true">2.</strong> Day 2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day2/lc977.html"><strong aria-hidden="true">2.1.</strong> 977. 有序数组的平方</a></li><li class="chapter-item expanded "><a href="day2/lc209.html"><strong aria-hidden="true">2.2.</strong> 209. 长度最小的子数组</a></li><li class="chapter-item expanded "><a href="day2/lc59.html"><strong aria-hidden="true">2.3.</strong> 59. 螺旋矩阵II</a></li></ol></li><li class="chapter-item expanded "><a href="day3.html"><strong aria-hidden="true">3.</strong> Day 3</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day3/lc203.html"><strong aria-hidden="true">3.1.</strong> 203. 移除链表元素</a></li><li class="chapter-item expanded "><a href="day3/lc707.html"><strong aria-hidden="true">3.2.</strong> 707. 设计链表</a></li><li class="chapter-item expanded "><a href="day3/lc206.html"><strong aria-hidden="true">3.3.</strong> 206. 反转链表</a></li></ol></li><li class="chapter-item expanded "><a href="day4.html"><strong aria-hidden="true">4.</strong> Day 4</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day4/lc24.html"><strong aria-hidden="true">4.1.</strong> 24. 两两交换链表中的节点</a></li></ol></li><li class="chapter-item expanded "><a href="day5.html"><strong aria-hidden="true">5.</strong> Day 5</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">代码随想录算法训练营刷题笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第一章--数组part01"><a class="header" href="#第一章--数组part01">第一章  数组part01</a></h1>
<h2 id="今日任务"><a class="header" href="#今日任务">今日任务</a></h2>
<p>数组理论基础，704. 二分查找，27. 移除元素</p>
<p>文章链接：https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</p>
<p>题目建议： 了解一下数组基础，以及数组的内存空间地址，数组也没那么简单。</p>
<h3 id="704-二分查找"><a class="header" href="#704-二分查找">704. 二分查找</a></h3>
<p>题目建议： 大家能把 704 掌握就可以，35.搜索插入位置 和 34. 在排序数组中查找元素的第一个和最后一个位置 ，如果有时间就去看一下，没时间可以先不看，二刷的时候在看。</p>
<p>先把 704写熟练，要熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法。</p>
<p>题目链接：https://leetcode.cn/problems/binary-search/</p>
<p>文章讲解：https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</p>
<p>视频讲解：https://www.bilibili.com/video/BV1fA4y1o715</p>
<h3 id="27-移除元素"><a class="header" href="#27-移除元素">27. 移除元素</a></h3>
<p>题目建议：  暴力的解法，可以锻炼一下我们的代码实现能力，建议先把暴力写法写一遍。 双指针法 是本题的精髓，今日需要掌握，至于拓展题目可以先不看。 </p>
<p>题目链接：https://leetcode.cn/problems/remove-element/ </p>
<p>文章讲解：https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html</p>
<p>视频讲解：https://www.bilibili.com/video/BV12A4y1Z7LP </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="704-二分查找-1"><a class="header" href="#704-二分查找-1">704. 二分查找</a></h1>
<h2 id="题目描述"><a class="header" href="#题目描述">题目描述</a></h2>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
示例 2:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1</p>
<h2 id="解题思路"><a class="header" href="#解题思路">解题思路</a></h2>
<p>直接使用标准库的做法，slice的partition_point没有找到的时候返回数组的长度</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn search(nums: Vec&lt;i32&gt;, target: i32) -&gt; i32 {
        let x = nums.partition_point(|&amp;x| x &lt; target);
        if x == nums.len() { return -1 }
        if nums[x] == target { return x as i32 }
        -1
    }
}
<span class="boring">}</span></code></pre></pre>
<p>手写的二分查找</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn search(nums: Vec&lt;i32&gt;, target: i32) -&gt; i32 {
        let mut left = 0;
        let mut right = nums.len();
        while left &lt; right {
            let mid = left + (right - left) / 2;
            if nums[mid] &lt; target {
                left = mid + 1
            } else if nums[mid] &gt; target {
                right = mid;
            } else {
                return mid as i32
            }
        }
        -1
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想"><a class="header" href="#学习感想">学习感想</a></h2>
<p>对区间的定义没有想清楚，<strong>区间的定义就是不变量</strong>，在操作的过程中 保持不变量</p>
<p>在左闭右闭区间的情况下 由于right 要 -1，所以要考虑right=0 - 1的情况</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn search(nums: Vec&lt;i32&gt;, target: i32) -&gt; i32 {
        let mut left = 0isize;
        let mut right = nums.len() as isize - 1;
        while left &lt;= right {
            let mid = (left + (right - left) / 2) as usize;
            if nums[mid] &lt; target {
                left = mid as isize + 1
            } else if nums[mid] &gt; target {
                right = mid as isize - 1;
            } else {
                return mid as i32
            }
        }
        -1
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="27-移除元素-1"><a class="header" href="#27-移除元素-1">27. 移除元素</a></h1>
<h2 id="题目描述-1"><a class="header" href="#题目描述-1">题目描述</a></h2>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>0 &lt;= nums.length &lt;= 100
0 &lt;= nums[i] &lt;= 50
0 &lt;= val &lt;= 100</p>
<h2 id="解题思路-1"><a class="header" href="#解题思路-1">解题思路</a></h2>
<p>线性算法，找到一个要移除的元素就和最后一个交换</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>
impl Solution {
    pub fn remove_element(nums: &amp;mut Vec&lt;i32&gt;, val: i32) -&gt; i32 {
        let n = nums.len();
        if n == 0 { return 0 }
        // [i,j) 表示还需要处理的区间，在这个区间之外的都是无需处理的
        let mut i = 0;
        let mut j = n;
        while i &lt; j {
            if nums[i] == val {
                j -= 1;
                nums[i] = nums[j];
            } else {
                i += 1;
            }
        }
        j as i32
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-1"><a class="header" href="#学习感想-1">学习感想</a></h2>
<p>一开始想的时候其实有不变量的思想在里面</p>
<p>写一下 双指针的版本</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn remove_element(nums: &amp;mut Vec&lt;i32&gt;, val: i32) -&gt; i32 {
        let mut a = 0;
        let mut b = 0;
        let n = nums.len();
        while b &lt; n {
            if nums[b] == val { b += 1 }
            else {
                nums[a] = nums[b];
                a += 1;
                b += 1;
            }
        }
        a as i32
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一章--数组part02"><a class="header" href="#第一章--数组part02">第一章  数组part02</a></h1>
<p>977.有序数组的平方 y，209.长度最小的子数组 ，59.螺旋矩阵II ，总结 </p>
<p>建议大家先独立做题，然后看视频讲解，然后看文章讲解，然后在重新做一遍题，把题目AC，最后整理成今日当天的博客</p>
<p>拓展题目可以先不做</p>
<p>详细布置</p>
<h2 id="977有序数组的平方"><a class="header" href="#977有序数组的平方">977.有序数组的平方</a></h2>
<p>题目建议： 本题关键在于理解双指针思想 </p>
<p>题目链接：https://leetcode.cn/problems/squares-of-a-sorted-array/
文章讲解：https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html
视频讲解： https://www.bilibili.com/video/BV1QB4y1D7ep </p>
<h2 id="209长度最小的子数组"><a class="header" href="#209长度最小的子数组">209.长度最小的子数组</a></h2>
<p>题目建议： 本题关键在于理解滑动窗口，这个滑动窗口看文字讲解 还挺难理解的，建议大家先看视频讲解。  拓展题目可以先不做。 </p>
<p>题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/
文章讲解：https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html
视频讲解：https://www.bilibili.com/video/BV1tZ4y1q7XE</p>
<h2 id="59螺旋矩阵ii"><a class="header" href="#59螺旋矩阵ii">59.螺旋矩阵II</a></h2>
<p>题目建议：  本题关键还是在转圈的逻辑，在二分搜索中提到的区间定义，在这里又用上了。 </p>
<p>题目链接：https://leetcode.cn/problems/spiral-matrix-ii/
文章讲解：https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html
视频讲解：https://www.bilibili.com/video/BV1SL4y1N7mV/</p>
<p>总结 </p>
<p>题目建议：希望大家 也做一个自己 对数组专题的总结</p>
<p>文章链接：https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="977-有序数组的平方"><a class="header" href="#977-有序数组的平方">977. 有序数组的平方</a></h1>
<h2 id="题目描述-2"><a class="header" href="#题目描述-2">题目描述</a></h2>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<h2 id="解题思路-2"><a class="header" href="#解题思路-2">解题思路</a></h2>
<p>有个很直接的方法是，先取绝对值，然后sort，然后平方</p>
<p>但是这个是nlogn的算法，想要一个n的算法，那很显然需要用到数组有序这个特性。</p>
<p>其实平方是无关紧要的操作。</p>
<p>找到最小的元素，然后向两边双边移动？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>
impl Solution {
    pub fn sorted_squares(mut nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
        nums.iter_mut()
            .filter(|&amp;&amp;mut x| x &lt; 0)
            .for_each(|x| *x = -*x);
        let low = nums.iter().enumerate()
            .fold((0, nums[0]), |(idx, v), (jdx, &amp;x)| {
                if x &lt; v { (jdx, x) } else { ( idx, v ) }
            }).0;
        if low == 0 { return nums.iter().map(|x| x**x).collect() }
        let mut left = low as isize - 1;
        let mut right = low + 1;
        let n = nums.len();
        let mut v = Vec::with_capacity(n);
        v.push(nums[low]);
        // left -&gt; 还需要处理的左侧第一个元素
        // right 还需要处理的右侧第一个元素
        while left &gt;= 0 &amp;&amp; right &lt; n {
            // 判断两侧
            if nums[left as usize] &lt; nums[right] {
                v.push(nums[left as usize]);
                left -= 1;
            } else {
                v.push(nums[right]);
                right += 1;
            }
        }
        if left &lt; 0 {
            while right &lt; n {
                v.push(nums[right]);
                right += 1;
            }
        } else {
            while left &gt;= 0 {
                v.push(nums[left as usize]);
                left -= 1;
            }
        }
        v.iter().map(|x| x**x).collect()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>写出来了，但是很长，确实定义的每一个变量的明确含义一定要在写之前就很清楚</p>
<h2 id="学习感想-2"><a class="header" href="#学习感想-2">学习感想</a></h2>
<p>数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>我是从最小数开始构建，确实麻烦，从最大的数开始构建就是一个简单一点的从两侧开始的双指针了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn sorted_squares(mut nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
        let n = nums.len();
        let mut v = Vec::with_capacity(n);
        let mut a = 0;
        let mut b = n as isize - 1;
        while a &lt;= b {
            if nums[a as usize].abs() &lt; nums[b as usize].abs() {
                v.push(nums[b as usize]);
                b -= 1;
            } else {
                v.push(nums[a as usize]);
                a += 1;
            }
        }
        v.iter().map(|x| x**x).rev().collect()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>注意是abs比较，a和b都是闭区间</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="209-长度最小的子数组"><a class="header" href="#209-长度最小的子数组">209. 长度最小的子数组</a></h1>
<h2 id="题目描述-3"><a class="header" href="#题目描述-3">题目描述</a></h2>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<h2 id="解题思路-3"><a class="header" href="#解题思路-3">解题思路</a></h2>
<p>哎写出来了但是很长，用双指针维护一个区间，相当于是循环不变量，</p>
<p>有一个观察：就是找到一个可行解后，第二个元素开始的可行解的最后一个元素一定大于或等于当前最后一个元素</p>
<p>所以不断地右侧生长去找到一个可行解，然后左侧缩小去尝试更小的解</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>
impl Solution {
    pub fn min_sub_array_len(target: i32, nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len();
        let mut a = 0;
        let mut b = 0;
        let mut s = 0;
        let mut res = 0;
        while s &lt; target &amp;&amp; b &lt; n {
            s += nums[b];b += 1;
        }
        if s &lt; target &amp;&amp;  b == n { return 0 }
        res = b;
        loop {

            while s &gt;= target &amp;&amp; a &lt; b {
                s -= nums[a];
                res = res.min(b - a);
                a += 1;
            }
            while s &lt; target &amp;&amp; b &lt; n {
                s += nums[b];b += 1;
            }
            if s &gt;= target {
                res = res.min(b - a);
            }
            if b == n &amp;&amp; s &lt; target { break }
        }

        res as i32
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-3"><a class="header" href="#学习感想-3">学习感想</a></h2>
<p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p>
<p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？</p>
<p>此时难免再次陷入 暴力解法的怪圈。</p>
<p>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。</p>
<p>原来是滑动窗口，只用一个变量来表示结束的位置</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>
impl Solution {
    pub fn min_sub_array_len(target: i32, nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len();
        let mut res = i32::MAX;
        let mut s = 0;
        let mut a = 0;
        for b in 0..n {
            s += nums[b];
            while s &gt;= target {
                res = res.min((b - a + 1) as i32);
                s -= nums[a];
                a += 1;
            }
        }
        if res == i32::MAX {0} else {res as i32}
    }
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="59-螺旋矩阵ii"><a class="header" href="#59-螺旋矩阵ii">59. 螺旋矩阵II</a></h1>
<h2 id="题目描述-4"><a class="header" href="#题目描述-4">题目描述</a></h2>
<p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>
<h2 id="解题思路-4"><a class="header" href="#解题思路-4">解题思路</a></h2>
<p>好像就是en做 
写出来了 但是很长，就是按照题目的意思进行模拟（迭代），每次迭代填入最外层的一圈</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>
impl Solution {
    pub fn generate_matrix(n: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
        let n = n as usize;
        let mut v = vec![vec![0; n]; n];
        // idx,idx 左上角的坐标， n 这一行的所有元素个数-1  右上角坐标idx,idx+n
        pub fn f(v: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, idx: usize, n: usize, start: i32) -&gt; i32 {
            if n == 0 { v[idx][idx] = start; return start + 1 }
            let mut cur = start;
            for j in 0..n {
                v[idx][idx+j] = cur ; cur += 1;
            }
            for i in 0..n {
                v[idx+i][idx+n] = cur ; cur += 1;
            }
            for j in 0..n {
                v[idx+n][idx+n-j] = cur ; cur += 1;
            }
            for i in 0..n {
                v[idx+n-i][idx] = cur ; cur += 1;
            }
            cur
        }
        let mut start = 1;
        let mut x = n as isize - 1;
        let mut i = 0;
        while x &gt;= 0 {
            start = f(&amp;mut v, i, x as usize, start);
            i += 1;
            x -= 2;
        }
        v
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-4"><a class="header" href="#学习感想-4">学习感想</a></h2>
<p>本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</p>
<p>坚持循环不变量原则</p>
<p>确实，定义一定要非常明确，明确了定义之后就牢牢地实现这个定义</p>
<p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是一进循环深似海，从此offer是路人。</p>
<p>然后好像就是我这种模拟的做法</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第二章-链表part01"><a class="header" href="#第二章-链表part01">第二章 链表part01</a></h1>
<p>day1 任务以及具体安排：https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY
day 2 任务以及具体安排：https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG 
今日任务 </p>
<p>● 链表理论基础 
● 203.移除链表元素 
● 707.设计链表 
● 206.反转链表 </p>
<p>详细布置 </p>
<p>链表理论基础 </p>
<p>建议：了解一下链接基础，以及链表和数组的区别 </p>
<p>文章链接：https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</p>
<h2 id="203移除链表元素"><a class="header" href="#203移除链表元素">203.移除链表元素</a></h2>
<p>建议： 本题最关键是要理解 虚拟头结点的使用技巧，这个对链表题目很重要。</p>
<p>题目链接/文章讲解/视频讲解：：https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html</p>
<h2 id="707设计链表"><a class="header" href="#707设计链表">707.设计链表</a></h2>
<p>建议： 这是一道考察 链表综合操作的题目，不算容易，可以练一练 使用虚拟头结点</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html</p>
<h2 id="206反转链表"><a class="header" href="#206反转链表">206.反转链表</a></h2>
<p>建议先看我的视频讲解，视频讲解中对 反转链表需要注意的点讲的很清晰了，看完之后大家的疑惑基本都解决了。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="203-移除链表元素"><a class="header" href="#203-移除链表元素">203. 移除链表元素</a></h1>
<h2 id="题目描述-5"><a class="header" href="#题目描述-5">题目描述</a></h2>
<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>
<h2 id="解题思路-5"><a class="header" href="#解题思路-5">解题思路</a></h2>
<p>链表题，hhhh，不是特别想用rust，不多说，直接操作ownersheip</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Solution {}

// Definition for singly-linked list.
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
  pub val: i32,
  pub next: Option&lt;Box&lt;ListNode&gt;&gt;
}

impl ListNode {
  #[inline]
  fn new(val: i32) -&gt; Self {
    ListNode {
      next: None,
      val
    }
  }
}

impl Solution {
    pub fn remove_elements(head: Option&lt;Box&lt;ListNode&gt;&gt;, val: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut head = Some(Box::new(ListNode { val: 0, next: head }));
        let mut a = &amp;mut head;
        while a.as_deref_mut().unwrap().next.is_some() {
            let v = a.as_deref_mut().unwrap().next.as_deref().unwrap().val;
            if v == val {
                let mut b = a.as_deref_mut().unwrap().next.take();
                let c = b.as_deref_mut().unwrap().next.take();
                a.as_deref_mut().unwrap().next = c;
            } else {
                let b = &amp;mut a.as_deref_mut().unwrap().next;
                a = b;
            }
        }
        head.unwrap().next
    }
}
<span class="boring">}</span></code></pre></pre>
<p>属实有点恶心了</p>
<h2 id="学习感想-5"><a class="header" href="#学习感想-5">学习感想</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span><span class="boring">
</span><span class="boring">// Definition for singly-linked list.
</span><span class="boring">#[derive(PartialEq, Eq, Clone, Debug)]
</span><span class="boring">pub struct ListNode {
</span><span class="boring">  pub val: i32,
</span><span class="boring">  pub next: Option&lt;Box&lt;ListNode&gt;&gt;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ListNode {
</span><span class="boring">  #[inline]
</span><span class="boring">  fn new(val: i32) -&gt; Self {
</span><span class="boring">    ListNode {
</span><span class="boring">      next: None,
</span><span class="boring">      val
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span>

impl Solution {
    pub fn remove_elements(head: Option&lt;Box&lt;ListNode&gt;&gt;, val: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut dummyHead = Box::new(ListNode::new(0));
        dummyHead.next = head;
        let mut cur = dummyHead.as_mut();
	// 使用take()替换std::men::replace(&amp;mut node.next, None)达到相同的效果，并且更普遍易读
        while let Some(nxt) = cur.next.take() {
            if nxt.val == val {
                cur.next = nxt.next;
            } else {
                cur.next = Some(nxt);
                cur = cur.next.as_mut().unwrap();
            }
        }
        dummyHead.next
    }
}
<span class="boring">}</span></code></pre></pre>
<p>向这位老哥学习，使用take，管它用不用，先取下来再说。并且 先把option刨了</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="707-设计链表"><a class="header" href="#707-设计链表">707. 设计链表</a></h1>
<h2 id="题目描述-6"><a class="header" href="#题目描述-6">题目描述</a></h2>
<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。</p>
<p>如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。</p>
<p>实现 MyLinkedList 类：</p>
<p>MyLinkedList() 初始化 MyLinkedList 对象。
int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。
void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。
void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。
void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。</p>
<h2 id="解题思路-6"><a class="header" href="#解题思路-6">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyLinkedList {
    val: i32,
    next: Option&lt;Box&lt;MyLinkedList&gt;&gt;
}


/**
 * `&amp;self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&amp;mut self` instead.
 */
impl MyLinkedList {

    fn new() -&gt; Self {
        Self { val: 0, next: None }
    }
    
    fn get(&amp;self, index: i32) -&gt; i32 {
        let mut dummpy = self.next.as_deref();
        let mut cnt = 0;
        while let Some(node) = dummpy {
            if index == cnt { return node.val }
            dummpy = node.next.as_deref();
            cnt += 1;
        }
        -1
    }
    
    fn add_at_head(&amp;mut self, val: i32) {
        self.next = Some(Box::new(
            MyLinkedList {
                val: val, 
                next: self.next.take()
            }
        ));
    }
    
    fn add_at_tail(&amp;mut self, val: i32) {
        let mut dummpy = self;
        while dummpy.next.is_some() {
            dummpy = dummpy.next.as_mut().unwrap();
        }
        dummpy.next = Some(Box::new(
            MyLinkedList {
                val: val, 
                next: None
            }
        ));
    }
    
    fn add_at_index(&amp;mut self, index: i32, val: i32) {
        let mut cnt = 0;
        let mut dummpy = self;
        while dummpy.next.is_some() {
            if cnt == index {
                let nxt = dummpy.next.take();
                dummpy.next = Some(Box::new(
                    MyLinkedList {
                        val: val, 
                        next: nxt
                    }
                ));
                return;
            }
            dummpy = dummpy.next.as_mut().unwrap();
            cnt += 1;
        }
        if cnt == index {
            dummpy.next = Some(Box::new(
                MyLinkedList {
                    val: val, 
                    next: None
                }
            ));
        }
    }
    
    fn delete_at_index(&amp;mut self, index: i32) {
        let mut cnt = 0;
        let mut dummpy = self;
        while dummpy.next.is_some() {
            if cnt == index {
                let nxt = dummpy.next.take().unwrap();
                dummpy.next = nxt.next;
                return;
            }
            dummpy = dummpy.next.as_mut().unwrap();
            cnt += 1;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-6"><a class="header" href="#学习感想-6">学习感想</a></h2>
<p>也没啥好说的，rust只要写出来，基本是对的，没有用take的形式，而是全部去除了option用ref</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="206-反转链表"><a class="header" href="#206-反转链表">206. 反转链表</a></h1>
<h2 id="题目描述-7"><a class="header" href="#题目描述-7">题目描述</a></h2>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<h2 id="解题思路-7"><a class="header" href="#解题思路-7">解题思路</a></h2>
<p>这就很简单了，一边出栈 一边入</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}

// Definition for singly-linked list.
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
  pub val: i32,
  pub next: Option&lt;Box&lt;ListNode&gt;&gt;
}

impl ListNode {
  #[inline]
  fn new(val: i32) -&gt; Self {
    ListNode {
      next: None,
      val
    }
  }
}


impl Solution {
    pub fn reverse_list(mut head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut dummy = Box::new(ListNode { val: 0, next: None });
        while let Some(mut node) = head {
            let tmp = dummy.next.take();
            let n = node.next.take();
            node.next = tmp;
            dummy.next = Some(node);
            head = n;
        }
        dummy.next
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-7"><a class="header" href="#学习感想-7">学习感想</a></h2>
<p>所以我这个算是什么方式</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id=""><a class="header" href="#"></a></h1>
<h2 id="题目描述-8"><a class="header" href="#题目描述-8">题目描述</a></h2>
<h2 id="解题思路-8"><a class="header" href="#解题思路-8">解题思路</a></h2>
<h2 id="学习感想-8"><a class="header" href="#学习感想-8">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
