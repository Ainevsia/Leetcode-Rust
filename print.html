<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>代码随想录算法训练营刷题笔记</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="day1.html"><strong aria-hidden="true">1.</strong> Day 1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day1/lc704.html"><strong aria-hidden="true">1.1.</strong> 704. 二分查找</a></li><li class="chapter-item expanded "><a href="day1/lc27.html"><strong aria-hidden="true">1.2.</strong> 27. 移除元素</a></li></ol></li><li class="chapter-item expanded "><a href="day2.html"><strong aria-hidden="true">2.</strong> Day 2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day2/lc977.html"><strong aria-hidden="true">2.1.</strong> 977. 有序数组的平方</a></li><li class="chapter-item expanded "><a href="day2/lc209.html"><strong aria-hidden="true">2.2.</strong> 209. 长度最小的子数组</a></li><li class="chapter-item expanded "><a href="day2/lc59.html"><strong aria-hidden="true">2.3.</strong> 59. 螺旋矩阵II</a></li></ol></li><li class="chapter-item expanded "><a href="day3.html"><strong aria-hidden="true">3.</strong> Day 3</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day3/lc203.html"><strong aria-hidden="true">3.1.</strong> 203. 移除链表元素</a></li><li class="chapter-item expanded "><a href="day3/lc707.html"><strong aria-hidden="true">3.2.</strong> 707. 设计链表</a></li><li class="chapter-item expanded "><a href="day3/lc206.html"><strong aria-hidden="true">3.3.</strong> 206. 反转链表</a></li></ol></li><li class="chapter-item expanded "><a href="day4.html"><strong aria-hidden="true">4.</strong> Day 4</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day4/lc24.html"><strong aria-hidden="true">4.1.</strong> 24. 两两交换链表中的节点</a></li><li class="chapter-item expanded "><a href="day4/lc19.html"><strong aria-hidden="true">4.2.</strong> 19. 删除链表的倒数第N个节点</a></li><li class="chapter-item expanded "><a href="day4/lc02.07.html"><strong aria-hidden="true">4.3.</strong> 面试题 02.07. 链表相交</a></li><li class="chapter-item expanded "><a href="day4/lc142.html"><strong aria-hidden="true">4.4.</strong> 142. 环形链表II</a></li></ol></li><li class="chapter-item expanded "><a href="day5.html"><strong aria-hidden="true">5.</strong> Day 5</a></li><li class="chapter-item expanded "><a href="day6.html"><strong aria-hidden="true">6.</strong> Day 6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day6/lc242.html"><strong aria-hidden="true">6.1.</strong> 242. 有效的字母异位词</a></li><li class="chapter-item expanded "><a href="day6/lc349.html"><strong aria-hidden="true">6.2.</strong> 349. 两个数组的交集</a></li><li class="chapter-item expanded "><a href="day6/lc202.html"><strong aria-hidden="true">6.3.</strong> 202. 快乐数</a></li><li class="chapter-item expanded "><a href="day6/lc1.html"><strong aria-hidden="true">6.4.</strong> 1. 两数之和</a></li></ol></li><li class="chapter-item expanded "><a href="day7.html"><strong aria-hidden="true">7.</strong> Day 7</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day7/lc454.html"><strong aria-hidden="true">7.1.</strong> 454. 四数相加II</a></li><li class="chapter-item expanded "><a href="day7/lc383.html"><strong aria-hidden="true">7.2.</strong> 383. 赎金信</a></li><li class="chapter-item expanded "><a href="day7/lc15.html"><strong aria-hidden="true">7.3.</strong> 15. 三数之和</a></li><li class="chapter-item expanded "><a href="day7/lc18.html"><strong aria-hidden="true">7.4.</strong> 18. 四数之和</a></li></ol></li><li class="chapter-item expanded "><a href="day8.html"><strong aria-hidden="true">8.</strong> Day 8</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day8/lc344.html"><strong aria-hidden="true">8.1.</strong> 344. 反转字符串</a></li><li class="chapter-item expanded "><a href="day8/lc541.html"><strong aria-hidden="true">8.2.</strong> 541. 反转字符串 II</a></li><li class="chapter-item expanded "><a href="day8/offer5.html"><strong aria-hidden="true">8.3.</strong> 剑指 Offer 05. 替换空格</a></li><li class="chapter-item expanded "><a href="day8/lc151.html"><strong aria-hidden="true">8.4.</strong> 151. 反转字符串中的单词</a></li><li class="chapter-item expanded "><a href="day8/offer58.html"><strong aria-hidden="true">8.5.</strong> 剑指 Offer 58 - II. 左旋转字符串</a></li></ol></li><li class="chapter-item expanded "><a href="day9.html"><strong aria-hidden="true">9.</strong> Day 9</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day9/lc28.html"><strong aria-hidden="true">9.1.</strong> 28. 找出字符串中第一个匹配项的下标</a></li><li class="chapter-item expanded "><a href="day9/lc459.html"><strong aria-hidden="true">9.2.</strong> 459. 重复的子字符串</a></li></ol></li><li class="chapter-item expanded "><a href="day10.html"><strong aria-hidden="true">10.</strong> Day 10</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day10/lc232.html"><strong aria-hidden="true">10.1.</strong> 232. 用栈实现队列</a></li><li class="chapter-item expanded "><a href="day10/lc255.html"><strong aria-hidden="true">10.2.</strong> 225. 用队列实现栈</a></li></ol></li><li class="chapter-item expanded "><a href="day11.html"><strong aria-hidden="true">11.</strong> Day 11</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day11/lc20.html"><strong aria-hidden="true">11.1.</strong> 20. 有效的括号</a></li><li class="chapter-item expanded "><a href="day11/lc1047.html"><strong aria-hidden="true">11.2.</strong> 1047. 删除字符串中的所有相邻重复项</a></li><li class="chapter-item expanded "><a href="day11/lc150.html"><strong aria-hidden="true">11.3.</strong> 150. 逆波兰表达式求值</a></li></ol></li><li class="chapter-item expanded "><a href="day12.html"><strong aria-hidden="true">12.</strong> Day 12</a></li><li class="chapter-item expanded "><a href="day13.html"><strong aria-hidden="true">13.</strong> Day 13</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day13/lc239.html"><strong aria-hidden="true">13.1.</strong> 239. 滑动窗口最大值</a></li><li class="chapter-item expanded "><a href="day13/lc347.html"><strong aria-hidden="true">13.2.</strong> 347. 前 K 个高频元素</a></li></ol></li><li class="chapter-item expanded "><a href="day14.html"><strong aria-hidden="true">14.</strong> day 14</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day14/lc144.html"><strong aria-hidden="true">14.1.</strong> 144. 二叉树的前序遍历</a></li></ol></li><li class="chapter-item expanded "><a href="day15.html"><strong aria-hidden="true">15.</strong> day 15</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day15/lc102.html"><strong aria-hidden="true">15.1.</strong> 102. 二叉树的层序遍历</a></li><li class="chapter-item expanded "><a href="day15/lc226.html"><strong aria-hidden="true">15.2.</strong> 226. 翻转二叉树</a></li><li class="chapter-item expanded "><a href="day15/lc101.html"><strong aria-hidden="true">15.3.</strong> 101. 对称二叉树</a></li></ol></li><li class="chapter-item expanded "><a href="day16.html"><strong aria-hidden="true">16.</strong> day 16</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day16/lc104.html"><strong aria-hidden="true">16.1.</strong> 104. 二叉树的最大深度</a></li><li class="chapter-item expanded "><a href="day16/lc111.html"><strong aria-hidden="true">16.2.</strong> 111. 二叉树的最小深度</a></li><li class="chapter-item expanded "><a href="day16/lc222.html"><strong aria-hidden="true">16.3.</strong> 222. 完全二叉树的节点个数</a></li></ol></li><li class="chapter-item expanded "><a href="day17.html"><strong aria-hidden="true">17.</strong> day 17</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day17/lc110.html"><strong aria-hidden="true">17.1.</strong> 110. 平衡二叉树</a></li><li class="chapter-item expanded "><a href="day17/lc257.html"><strong aria-hidden="true">17.2.</strong> 257. 二叉树的所有路径</a></li><li class="chapter-item expanded "><a href="day17/lc404.html"><strong aria-hidden="true">17.3.</strong> 404. 左叶子之和</a></li></ol></li><li class="chapter-item expanded "><a href="day18.html"><strong aria-hidden="true">18.</strong> day 18</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="day18/lc513.html"><strong aria-hidden="true">18.1.</strong> 513. 找树左下角的值</a></li><li class="chapter-item expanded "><a href="day18/lc112.html"><strong aria-hidden="true">18.2.</strong> 112. 路径总和</a></li><li class="chapter-item expanded "><a href="day18/lc106.html"><strong aria-hidden="true">18.3.</strong> 106. 从中序与后序遍历序列构造二叉树</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">代码随想录算法训练营刷题笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第一章--数组part01"><a class="header" href="#第一章--数组part01">第一章  数组part01</a></h1>
<h2 id="今日任务"><a class="header" href="#今日任务">今日任务</a></h2>
<p>数组理论基础，704. 二分查找，27. 移除元素</p>
<p>文章链接：https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</p>
<p>题目建议： 了解一下数组基础，以及数组的内存空间地址，数组也没那么简单。</p>
<h3 id="704-二分查找"><a class="header" href="#704-二分查找">704. 二分查找</a></h3>
<p>题目建议： 大家能把 704 掌握就可以，35.搜索插入位置 和 34. 在排序数组中查找元素的第一个和最后一个位置 ，如果有时间就去看一下，没时间可以先不看，二刷的时候在看。</p>
<p>先把 704写熟练，要熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法。</p>
<p>题目链接：https://leetcode.cn/problems/binary-search/</p>
<p>文章讲解：https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</p>
<p>视频讲解：https://www.bilibili.com/video/BV1fA4y1o715</p>
<h3 id="27-移除元素"><a class="header" href="#27-移除元素">27. 移除元素</a></h3>
<p>题目建议：  暴力的解法，可以锻炼一下我们的代码实现能力，建议先把暴力写法写一遍。 双指针法 是本题的精髓，今日需要掌握，至于拓展题目可以先不看。 </p>
<p>题目链接：https://leetcode.cn/problems/remove-element/ </p>
<p>文章讲解：https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html</p>
<p>视频讲解：https://www.bilibili.com/video/BV12A4y1Z7LP </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="704-二分查找-1"><a class="header" href="#704-二分查找-1">704. 二分查找</a></h1>
<h2 id="题目描述"><a class="header" href="#题目描述">题目描述</a></h2>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
示例 2:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1</p>
<h2 id="解题思路"><a class="header" href="#解题思路">解题思路</a></h2>
<p>直接使用标准库的做法，slice的partition_point没有找到的时候返回数组的长度</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn search(nums: Vec&lt;i32&gt;, target: i32) -&gt; i32 {
        let x = nums.partition_point(|&amp;x| x &lt; target);
        if x == nums.len() { return -1 }
        if nums[x] == target { return x as i32 }
        -1
    }
}
<span class="boring">}</span></code></pre></pre>
<p>手写的二分查找</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn search(nums: Vec&lt;i32&gt;, target: i32) -&gt; i32 {
        let mut left = 0;
        let mut right = nums.len();
        while left &lt; right {
            let mid = left + (right - left) / 2;
            if nums[mid] &lt; target {
                left = mid + 1
            } else if nums[mid] &gt; target {
                right = mid;
            } else {
                return mid as i32
            }
        }
        -1
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想"><a class="header" href="#学习感想">学习感想</a></h2>
<p>对区间的定义没有想清楚，<strong>区间的定义就是不变量</strong>，在操作的过程中 保持不变量</p>
<p>在左闭右闭区间的情况下 由于right 要 -1，所以要考虑right=0 - 1的情况</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn search(nums: Vec&lt;i32&gt;, target: i32) -&gt; i32 {
        let mut left = 0isize;
        let mut right = nums.len() as isize - 1;
        while left &lt;= right {
            let mid = (left + (right - left) / 2) as usize;
            if nums[mid] &lt; target {
                left = mid as isize + 1
            } else if nums[mid] &gt; target {
                right = mid as isize - 1;
            } else {
                return mid as i32
            }
        }
        -1
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="27-移除元素-1"><a class="header" href="#27-移除元素-1">27. 移除元素</a></h1>
<h2 id="题目描述-1"><a class="header" href="#题目描述-1">题目描述</a></h2>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>0 &lt;= nums.length &lt;= 100
0 &lt;= nums[i] &lt;= 50
0 &lt;= val &lt;= 100</p>
<h2 id="解题思路-1"><a class="header" href="#解题思路-1">解题思路</a></h2>
<p>线性算法，找到一个要移除的元素就和最后一个交换</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>
impl Solution {
    pub fn remove_element(nums: &amp;mut Vec&lt;i32&gt;, val: i32) -&gt; i32 {
        let n = nums.len();
        if n == 0 { return 0 }
        // [i,j) 表示还需要处理的区间，在这个区间之外的都是无需处理的
        let mut i = 0;
        let mut j = n;
        while i &lt; j {
            if nums[i] == val {
                j -= 1;
                nums[i] = nums[j];
            } else {
                i += 1;
            }
        }
        j as i32
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-1"><a class="header" href="#学习感想-1">学习感想</a></h2>
<p>一开始想的时候其实有不变量的思想在里面</p>
<p>写一下 双指针的版本</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn remove_element(nums: &amp;mut Vec&lt;i32&gt;, val: i32) -&gt; i32 {
        let mut a = 0;
        let mut b = 0;
        let n = nums.len();
        while b &lt; n {
            if nums[b] == val { b += 1 }
            else {
                nums[a] = nums[b];
                a += 1;
                b += 1;
            }
        }
        a as i32
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一章--数组part02"><a class="header" href="#第一章--数组part02">第一章  数组part02</a></h1>
<p>977.有序数组的平方 y，209.长度最小的子数组 ，59.螺旋矩阵II ，总结 </p>
<p>建议大家先独立做题，然后看视频讲解，然后看文章讲解，然后在重新做一遍题，把题目AC，最后整理成今日当天的博客</p>
<p>拓展题目可以先不做</p>
<p>详细布置</p>
<h2 id="977有序数组的平方"><a class="header" href="#977有序数组的平方">977.有序数组的平方</a></h2>
<p>题目建议： 本题关键在于理解双指针思想 </p>
<p>题目链接：https://leetcode.cn/problems/squares-of-a-sorted-array/
文章讲解：https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html
视频讲解： https://www.bilibili.com/video/BV1QB4y1D7ep </p>
<h2 id="209长度最小的子数组"><a class="header" href="#209长度最小的子数组">209.长度最小的子数组</a></h2>
<p>题目建议： 本题关键在于理解滑动窗口，这个滑动窗口看文字讲解 还挺难理解的，建议大家先看视频讲解。  拓展题目可以先不做。 </p>
<p>题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/
文章讲解：https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html
视频讲解：https://www.bilibili.com/video/BV1tZ4y1q7XE</p>
<h2 id="59螺旋矩阵ii"><a class="header" href="#59螺旋矩阵ii">59.螺旋矩阵II</a></h2>
<p>题目建议：  本题关键还是在转圈的逻辑，在二分搜索中提到的区间定义，在这里又用上了。 </p>
<p>题目链接：https://leetcode.cn/problems/spiral-matrix-ii/
文章讲解：https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html
视频讲解：https://www.bilibili.com/video/BV1SL4y1N7mV/</p>
<p>总结 </p>
<p>题目建议：希望大家 也做一个自己 对数组专题的总结</p>
<p>文章链接：https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="977-有序数组的平方"><a class="header" href="#977-有序数组的平方">977. 有序数组的平方</a></h1>
<h2 id="题目描述-2"><a class="header" href="#题目描述-2">题目描述</a></h2>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<h2 id="解题思路-2"><a class="header" href="#解题思路-2">解题思路</a></h2>
<p>有个很直接的方法是，先取绝对值，然后sort，然后平方</p>
<p>但是这个是nlogn的算法，想要一个n的算法，那很显然需要用到数组有序这个特性。</p>
<p>其实平方是无关紧要的操作。</p>
<p>找到最小的元素，然后向两边双边移动？</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>
impl Solution {
    pub fn sorted_squares(mut nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
        nums.iter_mut()
            .filter(|&amp;&amp;mut x| x &lt; 0)
            .for_each(|x| *x = -*x);
        let low = nums.iter().enumerate()
            .fold((0, nums[0]), |(idx, v), (jdx, &amp;x)| {
                if x &lt; v { (jdx, x) } else { ( idx, v ) }
            }).0;
        if low == 0 { return nums.iter().map(|x| x**x).collect() }
        let mut left = low as isize - 1;
        let mut right = low + 1;
        let n = nums.len();
        let mut v = Vec::with_capacity(n);
        v.push(nums[low]);
        // left -&gt; 还需要处理的左侧第一个元素
        // right 还需要处理的右侧第一个元素
        while left &gt;= 0 &amp;&amp; right &lt; n {
            // 判断两侧
            if nums[left as usize] &lt; nums[right] {
                v.push(nums[left as usize]);
                left -= 1;
            } else {
                v.push(nums[right]);
                right += 1;
            }
        }
        if left &lt; 0 {
            while right &lt; n {
                v.push(nums[right]);
                right += 1;
            }
        } else {
            while left &gt;= 0 {
                v.push(nums[left as usize]);
                left -= 1;
            }
        }
        v.iter().map(|x| x**x).collect()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>写出来了，但是很长，确实定义的每一个变量的明确含义一定要在写之前就很清楚</p>
<h2 id="学习感想-2"><a class="header" href="#学习感想-2">学习感想</a></h2>
<p>数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>我是从最小数开始构建，确实麻烦，从最大的数开始构建就是一个简单一点的从两侧开始的双指针了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn sorted_squares(mut nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
        let n = nums.len();
        let mut v = Vec::with_capacity(n);
        let mut a = 0;
        let mut b = n as isize - 1;
        while a &lt;= b {
            if nums[a as usize].abs() &lt; nums[b as usize].abs() {
                v.push(nums[b as usize]);
                b -= 1;
            } else {
                v.push(nums[a as usize]);
                a += 1;
            }
        }
        v.iter().map(|x| x**x).rev().collect()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>注意是abs比较，a和b都是闭区间</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="209-长度最小的子数组"><a class="header" href="#209-长度最小的子数组">209. 长度最小的子数组</a></h1>
<h2 id="题目描述-3"><a class="header" href="#题目描述-3">题目描述</a></h2>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<h2 id="解题思路-3"><a class="header" href="#解题思路-3">解题思路</a></h2>
<p>哎写出来了但是很长，用双指针维护一个区间，相当于是循环不变量，</p>
<p>有一个观察：就是找到一个可行解后，第二个元素开始的可行解的最后一个元素一定大于或等于当前最后一个元素</p>
<p>所以不断地右侧生长去找到一个可行解，然后左侧缩小去尝试更小的解</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>
impl Solution {
    pub fn min_sub_array_len(target: i32, nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len();
        let mut a = 0;
        let mut b = 0;
        let mut s = 0;
        let mut res = 0;
        while s &lt; target &amp;&amp; b &lt; n {
            s += nums[b];b += 1;
        }
        if s &lt; target &amp;&amp;  b == n { return 0 }
        res = b;
        loop {

            while s &gt;= target &amp;&amp; a &lt; b {
                s -= nums[a];
                res = res.min(b - a);
                a += 1;
            }
            while s &lt; target &amp;&amp; b &lt; n {
                s += nums[b];b += 1;
            }
            if s &gt;= target {
                res = res.min(b - a);
            }
            if b == n &amp;&amp; s &lt; target { break }
        }

        res as i32
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-3"><a class="header" href="#学习感想-3">学习感想</a></h2>
<p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p>
<p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？</p>
<p>此时难免再次陷入 暴力解法的怪圈。</p>
<p>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。</p>
<p>原来是滑动窗口，只用一个变量来表示结束的位置</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>
impl Solution {
    pub fn min_sub_array_len(target: i32, nums: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums.len();
        let mut res = i32::MAX;
        let mut s = 0;
        let mut a = 0;
        for b in 0..n {
            s += nums[b];
            while s &gt;= target {
                res = res.min((b - a + 1) as i32);
                s -= nums[a];
                a += 1;
            }
        }
        if res == i32::MAX {0} else {res as i32}
    }
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="59-螺旋矩阵ii"><a class="header" href="#59-螺旋矩阵ii">59. 螺旋矩阵II</a></h1>
<h2 id="题目描述-4"><a class="header" href="#题目描述-4">题目描述</a></h2>
<p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>
<h2 id="解题思路-4"><a class="header" href="#解题思路-4">解题思路</a></h2>
<p>好像就是en做 
写出来了 但是很长，就是按照题目的意思进行模拟（迭代），每次迭代填入最外层的一圈</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>
impl Solution {
    pub fn generate_matrix(n: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
        let n = n as usize;
        let mut v = vec![vec![0; n]; n];
        // idx,idx 左上角的坐标， n 这一行的所有元素个数-1  右上角坐标idx,idx+n
        pub fn f(v: &amp;mut Vec&lt;Vec&lt;i32&gt;&gt;, idx: usize, n: usize, start: i32) -&gt; i32 {
            if n == 0 { v[idx][idx] = start; return start + 1 }
            let mut cur = start;
            for j in 0..n {
                v[idx][idx+j] = cur ; cur += 1;
            }
            for i in 0..n {
                v[idx+i][idx+n] = cur ; cur += 1;
            }
            for j in 0..n {
                v[idx+n][idx+n-j] = cur ; cur += 1;
            }
            for i in 0..n {
                v[idx+n-i][idx] = cur ; cur += 1;
            }
            cur
        }
        let mut start = 1;
        let mut x = n as isize - 1;
        let mut i = 0;
        while x &gt;= 0 {
            start = f(&amp;mut v, i, x as usize, start);
            i += 1;
            x -= 2;
        }
        v
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-4"><a class="header" href="#学习感想-4">学习感想</a></h2>
<p>本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。</p>
<p>坚持循环不变量原则</p>
<p>确实，定义一定要非常明确，明确了定义之后就牢牢地实现这个定义</p>
<p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是一进循环深似海，从此offer是路人。</p>
<p>然后好像就是我这种模拟的做法</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第二章-链表part01"><a class="header" href="#第二章-链表part01">第二章 链表part01</a></h1>
<p>day1 任务以及具体安排：https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY
day 2 任务以及具体安排：https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG 
今日任务 </p>
<p>● 链表理论基础 
● 203.移除链表元素 
● 707.设计链表 
● 206.反转链表 </p>
<p>详细布置 </p>
<p>链表理论基础 </p>
<p>建议：了解一下链接基础，以及链表和数组的区别 </p>
<p>文章链接：https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</p>
<h2 id="203移除链表元素"><a class="header" href="#203移除链表元素">203.移除链表元素</a></h2>
<p>建议： 本题最关键是要理解 虚拟头结点的使用技巧，这个对链表题目很重要。</p>
<p>题目链接/文章讲解/视频讲解：：https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html</p>
<h2 id="707设计链表"><a class="header" href="#707设计链表">707.设计链表</a></h2>
<p>建议： 这是一道考察 链表综合操作的题目，不算容易，可以练一练 使用虚拟头结点</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html</p>
<h2 id="206反转链表"><a class="header" href="#206反转链表">206.反转链表</a></h2>
<p>建议先看我的视频讲解，视频讲解中对 反转链表需要注意的点讲的很清晰了，看完之后大家的疑惑基本都解决了。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="203-移除链表元素"><a class="header" href="#203-移除链表元素">203. 移除链表元素</a></h1>
<h2 id="题目描述-5"><a class="header" href="#题目描述-5">题目描述</a></h2>
<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>
<h2 id="解题思路-5"><a class="header" href="#解题思路-5">解题思路</a></h2>
<p>链表题，hhhh，不是特别想用rust，不多说，直接操作ownersheip</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Solution {}

// Definition for singly-linked list.
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
  pub val: i32,
  pub next: Option&lt;Box&lt;ListNode&gt;&gt;
}

impl ListNode {
  #[inline]
  fn new(val: i32) -&gt; Self {
    ListNode {
      next: None,
      val
    }
  }
}

impl Solution {
    pub fn remove_elements(head: Option&lt;Box&lt;ListNode&gt;&gt;, val: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut head = Some(Box::new(ListNode { val: 0, next: head }));
        let mut a = &amp;mut head;
        while a.as_deref_mut().unwrap().next.is_some() {
            let v = a.as_deref_mut().unwrap().next.as_deref().unwrap().val;
            if v == val {
                let mut b = a.as_deref_mut().unwrap().next.take();
                let c = b.as_deref_mut().unwrap().next.take();
                a.as_deref_mut().unwrap().next = c;
            } else {
                let b = &amp;mut a.as_deref_mut().unwrap().next;
                a = b;
            }
        }
        head.unwrap().next
    }
}
<span class="boring">}</span></code></pre></pre>
<p>属实有点恶心了</p>
<h2 id="学习感想-5"><a class="header" href="#学习感想-5">学习感想</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span><span class="boring">
</span><span class="boring">// Definition for singly-linked list.
</span><span class="boring">#[derive(PartialEq, Eq, Clone, Debug)]
</span><span class="boring">pub struct ListNode {
</span><span class="boring">  pub val: i32,
</span><span class="boring">  pub next: Option&lt;Box&lt;ListNode&gt;&gt;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ListNode {
</span><span class="boring">  #[inline]
</span><span class="boring">  fn new(val: i32) -&gt; Self {
</span><span class="boring">    ListNode {
</span><span class="boring">      next: None,
</span><span class="boring">      val
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span>

impl Solution {
    pub fn remove_elements(head: Option&lt;Box&lt;ListNode&gt;&gt;, val: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut dummyHead = Box::new(ListNode::new(0));
        dummyHead.next = head;
        let mut cur = dummyHead.as_mut();
	// 使用take()替换std::men::replace(&amp;mut node.next, None)达到相同的效果，并且更普遍易读
        while let Some(nxt) = cur.next.take() {
            if nxt.val == val {
                cur.next = nxt.next;
            } else {
                cur.next = Some(nxt);
                cur = cur.next.as_mut().unwrap();
            }
        }
        dummyHead.next
    }
}
<span class="boring">}</span></code></pre></pre>
<p>向这位老哥学习，使用take，管它用不用，先取下来再说。并且 先把option刨了</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="707-设计链表"><a class="header" href="#707-设计链表">707. 设计链表</a></h1>
<h2 id="题目描述-6"><a class="header" href="#题目描述-6">题目描述</a></h2>
<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。</p>
<p>如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。</p>
<p>实现 MyLinkedList 类：</p>
<p>MyLinkedList() 初始化 MyLinkedList 对象。
int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。
void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。
void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。
void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。</p>
<h2 id="解题思路-6"><a class="header" href="#解题思路-6">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyLinkedList {
    val: i32,
    next: Option&lt;Box&lt;MyLinkedList&gt;&gt;
}


/**
 * `&amp;self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&amp;mut self` instead.
 */
impl MyLinkedList {

    fn new() -&gt; Self {
        Self { val: 0, next: None }
    }
    
    fn get(&amp;self, index: i32) -&gt; i32 {
        let mut dummpy = self.next.as_deref();
        let mut cnt = 0;
        while let Some(node) = dummpy {
            if index == cnt { return node.val }
            dummpy = node.next.as_deref();
            cnt += 1;
        }
        -1
    }
    
    fn add_at_head(&amp;mut self, val: i32) {
        self.next = Some(Box::new(
            MyLinkedList {
                val: val, 
                next: self.next.take()
            }
        ));
    }
    
    fn add_at_tail(&amp;mut self, val: i32) {
        let mut dummpy = self;
        while dummpy.next.is_some() {
            dummpy = dummpy.next.as_mut().unwrap();
        }
        dummpy.next = Some(Box::new(
            MyLinkedList {
                val: val, 
                next: None
            }
        ));
    }
    
    fn add_at_index(&amp;mut self, index: i32, val: i32) {
        let mut cnt = 0;
        let mut dummpy = self;
        while dummpy.next.is_some() {
            if cnt == index {
                let nxt = dummpy.next.take();
                dummpy.next = Some(Box::new(
                    MyLinkedList {
                        val: val, 
                        next: nxt
                    }
                ));
                return;
            }
            dummpy = dummpy.next.as_mut().unwrap();
            cnt += 1;
        }
        if cnt == index {
            dummpy.next = Some(Box::new(
                MyLinkedList {
                    val: val, 
                    next: None
                }
            ));
        }
    }
    
    fn delete_at_index(&amp;mut self, index: i32) {
        let mut cnt = 0;
        let mut dummpy = self;
        while dummpy.next.is_some() {
            if cnt == index {
                let nxt = dummpy.next.take().unwrap();
                dummpy.next = nxt.next;
                return;
            }
            dummpy = dummpy.next.as_mut().unwrap();
            cnt += 1;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-6"><a class="header" href="#学习感想-6">学习感想</a></h2>
<p>也没啥好说的，rust只要写出来，基本是对的，没有用take的形式，而是全部去除了option用ref</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="206-反转链表"><a class="header" href="#206-反转链表">206. 反转链表</a></h1>
<h2 id="题目描述-7"><a class="header" href="#题目描述-7">题目描述</a></h2>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<h2 id="解题思路-7"><a class="header" href="#解题思路-7">解题思路</a></h2>
<p>这就很简单了，一边出栈 一边入</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}

// Definition for singly-linked list.
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
  pub val: i32,
  pub next: Option&lt;Box&lt;ListNode&gt;&gt;
}

impl ListNode {
  #[inline]
  fn new(val: i32) -&gt; Self {
    ListNode {
      next: None,
      val
    }
  }
}


impl Solution {
    pub fn reverse_list(mut head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut dummy = Box::new(ListNode { val: 0, next: None });
        while let Some(mut node) = head {
            let tmp = dummy.next.take();
            let n = node.next.take();
            node.next = tmp;
            dummy.next = Some(node);
            head = n;
        }
        dummy.next
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-7"><a class="header" href="#学习感想-7">学习感想</a></h2>
<p>所以我这个算是什么方式</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第二章-链表part02"><a class="header" href="#第二章-链表part02">第二章 链表part02</a></h1>
<p>● day 1 任务以及具体安排：https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY 
● day 2 任务以及具体安排：https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG 
● day 3 任务以及具体安排：https://docs.qq.com/doc/DUGdqYWNYeGhlaVR6</p>
<p>今日任务 </p>
<p>● 24. 两两交换链表中的节点 
● 19.删除链表的倒数第N个节点 
● 面试题 02.07. 链表相交 
● 142.环形链表II 
● 总结</p>
<p>详细布置 </p>
<h2 id="24-两两交换链表中的节点"><a class="header" href="#24-两两交换链表中的节点">24. 两两交换链表中的节点</a></h2>
<p>用虚拟头结点，这样会方便很多。 </p>
<p>本题链表操作就比较复杂了，建议大家先看视频，视频里我讲解了注意事项，为什么需要temp保存临时节点。</p>
<p>题目链接/文章讲解/视频讲解： https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</p>
<h2 id="19删除链表的倒数第n个节点"><a class="header" href="#19删除链表的倒数第n个节点">19.删除链表的倒数第N个节点</a></h2>
<p>双指针的操作，要注意，删除第N个节点，那么我们当前遍历的指针一定要指向 第N个节点的前一个节点，建议先看视频。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html</p>
<h2 id="面试题-0207-链表相交"><a class="header" href="#面试题-0207-链表相交">面试题 02.07. 链表相交</a></h2>
<p>本题没有视频讲解，大家注意 数值相同，不代表指针相同。</p>
<p>题目链接/文章讲解：https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html</p>
<h2 id="142环形链表ii"><a class="header" href="#142环形链表ii">142.环形链表II</a></h2>
<p>算是链表比较有难度的题目，需要多花点时间理解 确定环和找环入口，建议先看视频。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="24-两两交换链表中的节点-1"><a class="header" href="#24-两两交换链表中的节点-1">24. 两两交换链表中的节点</a></h1>
<h2 id="题目描述-8"><a class="header" href="#题目描述-8">题目描述</a></h2>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<h2 id="解题思路-8"><a class="header" href="#解题思路-8">解题思路</a></h2>
<p>? 还是一边出 一边入</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}

// Definition for singly-linked list.
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
  pub val: i32,
  pub next: Option&lt;Box&lt;ListNode&gt;&gt;
}

impl ListNode {
  #[inline]
  fn new(val: i32) -&gt; Self {
    ListNode {
      next: None,
      val
    }
  }
}

impl Solution {
    pub fn swap_pairs(mut head: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut dummy = Box::new(ListNode { val: 0, next: None });
        let mut cdummy = &amp;mut dummy;
        while let Some(mut x) = head.take() {
            if x.next.is_none() {
                cdummy.next = Some(x);
                return dummy.next;
            }
            if let Some(mut y) = x.next.take() {
                head = y.next.take();
                y.next = Some(x);
                cdummy.next = Some(y);
                cdummy = cdummy.next.as_mut().unwrap();
                cdummy = cdummy.next.as_mut().unwrap();
            }
        }
        dummy.next
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-8"><a class="header" href="#学习感想-8">学习感想</a></h2>
<p>我发现我做链表逆序 两两交换的时候都是直接新建一个存返回链表的dummy头节点，然后按照操作来把节点从原来的链表里取出来插入新的链表中，根本不用想怎么修改指针</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-删除链表的倒数第-n-个结点"><a class="header" href="#19-删除链表的倒数第-n-个结点">19. 删除链表的倒数第 N 个结点</a></h1>
<h2 id="题目描述-9"><a class="header" href="#题目描述-9">题目描述</a></h2>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<h2 id="解题思路-9"><a class="header" href="#解题思路-9">解题思路</a></h2>
<p>之前用dummy 重新构造新的链表来做的</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}

// Definition for singly-linked list.
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
  pub val: i32,
  pub next: Option&lt;Box&lt;ListNode&gt;&gt;
}

impl ListNode {
  #[inline]
  fn new(val: i32) -&gt; Self {
    ListNode {
      next: None,
      val
    }
  }
}

impl Solution {
    pub fn remove_nth_from_end(mut head: Option&lt;Box&lt;ListNode&gt;&gt;, n: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut dummy = ListNode::new(-1);
        while let Some(mut x) = head {
            head = x.next;
            x.next = dummy.next;
            dummy.next = Some(x);
        }
        let mut ptr = &amp;mut dummy;
        for _ in 1..n { ptr = ptr.next.as_deref_mut().unwrap() }
        let drop = ptr.next.take();
        ptr.next = drop?.next.take();
        head = dummy.next.take();
        while let Some(mut x) = head {
            head = x.next;
            x.next = dummy.next;
            dummy.next = Some(x);
        }
        dummy.next
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-9"><a class="header" href="#学习感想-9">学习感想</a></h2>
<p>双指针法这道题用safe rust没法写，因为需要同时持有链表的两个引用，并且头部的引用还必须是可变引用，这是没法做到的</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}

// Definition for singly-linked list.
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
  pub val: i32,
  pub next: Option&lt;Box&lt;ListNode&gt;&gt;
}

impl ListNode {
  #[inline]
  fn new(val: i32) -&gt; Self {
    ListNode {
      next: None,
      val
    }
  }
}
impl Solution {
    pub fn remove_nth_from_end(head: Option&lt;Box&lt;ListNode&gt;&gt;, n: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        unsafe {
            let dummy = ListNode { val: -1, next: head };
            let mut ptr = &amp;dummy;
            for _ in 0..n { ptr = ptr.next.as_deref()? }
            let mut ptr2 = &amp;dummy as *const ListNode as *mut ListNode;
            while ptr.next.is_some() {
                ptr = ptr.next.as_deref()?;
                ptr2 = (*ptr2).next.as_deref()? as *const ListNode as *mut ListNode;
            }
            let mut rigoff = (*ptr2).next.take()?;
            let nxt = rigoff.next.take();
            (*ptr2).next = nxt;
            dummy.next
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>所以这就是我用unsafe的原因</p>
<h1 id="unsafe-superpowers"><a class="header" href="#unsafe-superpowers">Unsafe Superpowers</a></h1>
<p>To switch to unsafe Rust, use the unsafe keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust that you can’t in safe Rust, which we call unsafe superpowers. Those superpowers include the ability to:</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
<li>Access fields of unions</li>
</ul>
<p><strong>It’s important to understand that unsafe doesn’t turn off the borrow checker or disable any other of Rust’s safety checks: if you use a reference in unsafe code, it will still be checked.</strong> The unsafe keyword only gives you access to these five features that are then not checked by the compiler for memory safety. You’ll still get some degree of safety inside of an unsafe block.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="面试题-0207-链表相交-1"><a class="header" href="#面试题-0207-链表相交-1">面试题 02.07. 链表相交</a></h1>
<h2 id="题目描述-10"><a class="header" href="#题目描述-10">题目描述</a></h2>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？</p>
<h2 id="解题思路-10"><a class="header" href="#解题思路-10">解题思路</a></h2>
<p>这题没有rust选</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        la = 1
        lb = 1
        ptra = headA
        ptrb = headB
        if ptra is None or ptrb is None:
            return None
        while ptra.next != None:
            la += 1
            ptra = ptra.next
        while ptrb.next != None:
            lb += 1
            ptrb = ptrb.next
        if la &lt; lb:
            ptra, ptrb = headB, headA
        else:
            ptra, ptrb = headA, headB

        d = abs(la - lb)
        print(d, la, lb)
        for i in range(d):
            ptra = ptra.next
        for i in range(min(la,lb)):
            if ptra is ptrb:
                return ptra
            else:
                ptra = ptra.next
                ptrb = ptrb.next
        return None

</code></pre>
<h2 id="学习感想-10"><a class="header" href="#学习感想-10">学习感想</a></h2>
<p>看解析之前没有想到这个做法</p>
<p>重点是尾部对其，</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="142环形链表ii-1"><a class="header" href="#142环形链表ii-1">142.环形链表II</a></h1>
<h2 id="题目描述-11"><a class="header" href="#题目描述-11">题目描述</a></h2>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<h2 id="解题思路-11"><a class="header" href="#解题思路-11">解题思路</a></h2>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        fast = head
        slow = head
        while fast != None and fast.next != None and fast.next.next != None:
            fast = fast.next.next
            slow = slow.next
            if fast is slow:
                # found in loop
                newindex = head
                while not newindex is fast:
                    fast = fast.next
                    newindex = newindex.next
                return fast
        return None
</code></pre>
<h2 id="学习感想-11"><a class="header" href="#学习感想-11">学习感想</a></h2>
<p>一刷 数学题 不会，快慢指针会的，但是数学推导没有想到</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="休息日"><a class="header" href="#休息日">休息日</a></h1>
<p>休息日我用来补进度了</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第三章-哈希表part01"><a class="header" href="#第三章-哈希表part01">第三章 哈希表part01</a></h1>
<p>今日任务 </p>
<p>● 哈希表理论基础 
● 242.有效的字母异位词 
● 349. 两个数组的交集 
● 202. 快乐数
● 1. 两数之和</p>
<p>详细布置 </p>
<h2 id="哈希表理论基础"><a class="header" href="#哈希表理论基础">哈希表理论基础</a></h2>
<p>建议：大家要了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和map。</p>
<p>什么时候想到用哈希法，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。  这句话很重要，大家在做哈希表题目都要思考这句话。 </p>
<p>文章讲解：https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</p>
<h2 id="242有效的字母异位词"><a class="header" href="#242有效的字母异位词">242.有效的字母异位词</a></h2>
<p>建议： 这道题目，大家可以感受到 数组 用来做哈希表 给我们带来的遍历之处。 </p>
<p>题目链接/文章讲解/视频讲解： https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html</p>
<h2 id="349-两个数组的交集"><a class="header" href="#349-两个数组的交集">349. 两个数组的交集</a></h2>
<p>建议：本题就开始考虑 什么时候用set 什么时候用数组，本题其实是使用set的好题，但是后来力扣改了题目描述和 测试用例，添加了 0 &lt;= nums1[i], nums2[i] &lt;= 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html</p>
<h2 id="202-快乐数"><a class="header" href="#202-快乐数">202. 快乐数</a></h2>
<p>建议：这道题目也是set的应用，其实和上一题差不多，就是 套在快乐数一个壳子 </p>
<p>题目链接/文章讲解：https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html</p>
<h2 id="1-两数之和"><a class="header" href="#1-两数之和">1. 两数之和</a></h2>
<p>建议：本题虽然是 力扣第一题，但是还是挺难的，也是 代码随想录中 数组，set之后，使用map解决哈希问题的第一题。 </p>
<p>建议大家先看视频讲解，然后尝试自己写代码，在看文章讲解，加深印象。 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="242-有效的字母异位词"><a class="header" href="#242-有效的字母异位词">242. 有效的字母异位词</a></h1>
<h2 id="题目描述-12"><a class="header" href="#题目描述-12">题目描述</a></h2>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>
<h2 id="解题思路-12"><a class="header" href="#解题思路-12">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn is_anagram(s: String, t: String) -&gt; bool {
        use std::collections::HashMap;
        if s.len() != t.len() { return false }
        let mut freq: HashMap&lt;char, usize&gt; = HashMap::new();
        for c in s.chars() {
            *freq.entry(c).or_default() += 1;
        }
        for c in t.chars() {
            let entry = freq.entry(c).or_default();
            if *entry == 0 { return false }
            *entry -= 1;
        }
        true
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-12"><a class="header" href="#学习感想-12">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="349-两个数组的交集-1"><a class="header" href="#349-两个数组的交集-1">349. 两个数组的交集</a></h1>
<h2 id="题目描述-13"><a class="header" href="#题目描述-13">题目描述</a></h2>
<p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
<h2 id="解题思路-13"><a class="header" href="#解题思路-13">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>
impl Solution {
    pub fn intersection(nums1: Vec&lt;i32&gt;, nums2: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
        use std::collections::HashSet;
        let mut set1 = HashSet::new();
        let mut set2 = HashSet::new();
        for i in nums1 {
            set1.insert(i);
        }
        for i in nums2 {
            set2.insert(i);
        }
        set1.intersection(&amp;set2).copied().collect()
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-13"><a class="header" href="#学习感想-13">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="202-快乐数-1"><a class="header" href="#202-快乐数-1">202. 快乐数</a></h1>
<h2 id="题目描述-14"><a class="header" href="#题目描述-14">题目描述</a></h2>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」 定义为：</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果这个过程 结果为 1，那么这个数就是快乐数。
如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p>
<h2 id="解题思路-14"><a class="header" href="#解题思路-14">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>impl Solution {
    pub fn is_happy(mut n: i32) -&gt; bool {
        use std::collections::HashSet;
        let mut set = HashSet::new();
        set.insert(n);
        fn f(mut n: i32) -&gt; i32 {
            let mut res = 0;
            while n != 0 {
                let x = n % 10;
                res += x * x;
                n /= 10;
            }
            res
        }
        loop {
            n = f(n);
            if n == 1 { return true }
            if set.contains(&amp;n) { return false }
            set.insert(n);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-14"><a class="header" href="#学习感想-14">学习感想</a></h2>
<p>一下子不知道怎么做，但是把false的例子弄明白就知道了</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-两数之和-1"><a class="header" href="#1-两数之和-1">1. 两数之和</a></h1>
<h2 id="题目描述-15"><a class="header" href="#题目描述-15">题目描述</a></h2>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<h2 id="解题思路-15"><a class="header" href="#解题思路-15">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Solution {}
</span>

impl Solution {
    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {
        use std::collections::HashMap;
        let mut map: HashMap&lt;i32, i32&gt; = HashMap::new();
        for (idx, i) in nums.iter().enumerate() {
            if map.contains_key(&amp;(target - i)) {
                return vec![*map.get(&amp;(target - i)).unwrap(), idx as i32]
            } else {
                map.insert(*i, idx as i32);
            }
        }
        todo!()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-15"><a class="header" href="#学习感想-15">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第三章-哈希表part02"><a class="header" href="#第三章-哈希表part02">第三章 哈希表part02</a></h1>
<p>今日任务 </p>
<p>● 454.四数相加II 
● 383. 赎金信 
● 15. 三数之和 
● 18. 四数之和 
● 总结</p>
<p>详细布置 </p>
<h2 id="454-四数相加ii"><a class="header" href="#454-四数相加ii">454. 四数相加II</a></h2>
<p>建议：本题是 使用map 巧妙解决的问题，好好体会一下 哈希法 如何提高程序执行效率，降低时间复杂度，当然使用哈希法 会提高空间复杂度，但一般来说我们都是舍空间 换时间， 工业开发也是这样。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html</p>
<h2 id="383-赎金信"><a class="header" href="#383-赎金信">383. 赎金信</a></h2>
<p>建议：本题 和 242.有效的字母异位词 是一个思路 ，算是拓展题 </p>
<p>题目链接/文章讲解：https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html </p>
<h2 id="15-三数之和"><a class="header" href="#15-三数之和">15. 三数之和</a></h2>
<p>建议：本题虽然和 两数之和 很像，也能用哈希法，但用哈希法会很麻烦，双指针法才是正解，可以先看视频理解一下 双指针法的思路，文章中讲解的，没问题 哈希法很麻烦。 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html </p>
<h2 id="18-四数之和"><a class="header" href="#18-四数之和">18. 四数之和</a></h2>
<p>建议： 要比较一下，本题和 454.四数相加II 的区别，为什么 454.四数相加II 会简单很多，这个想明白了，对本题理解就深刻了。 本题 思路整体和 三数之和一样的，都是双指针，但写的时候 有很多小细节，需要注意，建议先看视频。 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="454-四数相加-ii"><a class="header" href="#454-四数相加-ii">454. 四数相加 II</a></h1>
<h2 id="题目描述-16"><a class="header" href="#题目描述-16">题目描述</a></h2>
<p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>
<p>0 &lt;= i, j, k, l &lt; n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</p>
<h2 id="解题思路-16"><a class="header" href="#解题思路-16">解题思路</a></h2>
<p>首先是一种愚蠢的做法，以为On2就是两个for循环</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Solution {}

impl Solution {
    pub fn four_sum_count(nums1: Vec&lt;i32&gt;, nums2: Vec&lt;i32&gt;, nums3: Vec&lt;i32&gt;, nums4: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums1.len();
        use std::collections::HashMap;
        let mut res = 0;
        let mut map3: HashMap&lt;i32, usize&gt; = HashMap::new();
        let mut map4: HashMap&lt;i32, usize&gt; = HashMap::new();
        for i in 0..n {
            *map3.entry(nums3[i]).or_default() += 1;
            *map4.entry(nums4[i]).or_default() += 1;
        }
        for i in 0..n {
            for j in 0..n {
                let mut target = - nums1[i] - nums2[j];
                for (&amp;a, &amp;b) in map3.iter() {
                    let d = target - a;
                    if map4.contains_key(&amp;d) {
                        res += b * map4.get(&amp;d).unwrap();
                    }
                }
            }
        }
        res as i32
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这里面白白浪费了i和j的和</p>
<h2 id="学习感想-16"><a class="header" href="#学习感想-16">学习感想</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>

<span class="boring">fn main() {
</span>struct Solution {}


impl Solution {
    pub fn four_sum_count(nums1: Vec&lt;i32&gt;, nums2: Vec&lt;i32&gt;, nums3: Vec&lt;i32&gt;, nums4: Vec&lt;i32&gt;) -&gt; i32 {
        let n = nums1.len();
        use std::collections::HashMap;
        let mut res = 0;
        let mut map: HashMap&lt;i32, usize&gt; = HashMap::new();
        for i in 0..n {
            for j in 0..n {
                let target = nums1[i] + nums2[j];
                *map.entry(target).or_default() += 1;
            }
        }
        for i in 0..n {
            for j in 0..n {
                let target = - nums3[i] - nums4[j];
                if map.contains_key(&amp;target) {
                    res += map.get(&amp;target).unwrap();
                }
            }
        }
        res as i32
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="383-赎金信-1"><a class="header" href="#383-赎金信-1">383. 赎金信</a></h1>
<h2 id="题目描述-17"><a class="header" href="#题目描述-17">题目描述</a></h2>
<p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p>
<p>如果可以，返回 true ；否则返回 false 。</p>
<p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
<h2 id="解题思路-17"><a class="header" href="#解题思路-17">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}

impl Solution {
    pub fn can_construct(ransom_note: String, magazine: String) -&gt; bool {
        use std::collections::HashMap;
        let mut map: HashMap&lt;char, usize&gt; = HashMap::new();
        for c in magazine.chars() {
            *map.entry(c).or_default() += 1;
        }
        for c in ransom_note.chars() {
            if ! map.contains_key(&amp;c) { return false }
            let a = map.get_mut(&amp;c).unwrap();
            *a -= 1;
            if *a == 0 { map.remove(&amp;c); }
        }
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-17"><a class="header" href="#学习感想-17">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-三数之和-1"><a class="header" href="#15-三数之和-1">15. 三数之和</a></h1>
<h2 id="题目描述-18"><a class="header" href="#题目描述-18">题目描述</a></h2>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p>
<p>你返回所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<h2 id="解题思路-18"><a class="header" href="#解题思路-18">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}

impl Solution {
    pub fn three_sum(mut v: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
        v.sort();
        let mut ans = vec![];
        for i in 0..v.len() - 2 {
            if i &gt; 0 &amp;&amp; v[i] == v[i - 1] {
                continue;
            }
            let mut j = i + 1;
            let mut k = v.len() - 1;
            while j &lt; k {
                if v[j] + v[k] + v[i] == 0 {
                    ans.push(vec![v[i], v[j], v[k]]);
                    j += 1;
                    while j &lt; k &amp;&amp; v[j] == v[j - 1] {
                        j += 1
                    }
                    k -= 1;
                    while j &lt; k &amp;&amp; v[k] == v[k + 1] {
                        k -= 1
                    }
                } else if v[j] + v[k] &lt; -v[i] {
                    j += 1
                } else {
                    k -= 1
                }
            }
        }
        ans
    }
}
<span class="boring">}</span></code></pre></pre>
<p>双指针做法还是想不到</p>
<h2 id="学习感想-18"><a class="header" href="#学习感想-18">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-四数之和-1"><a class="header" href="#18-四数之和-1">18. 四数之和</a></h1>
<h2 id="题目描述-19"><a class="header" href="#题目描述-19">题目描述</a></h2>
<p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<p>0 &lt;= a, b, c, d &lt; n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。</p>
<h2 id="解题思路-19"><a class="header" href="#解题思路-19">解题思路</a></h2>
<p>有两个坑：</p>
<ul>
<li>首先是n &lt; 4的情况是存在的</li>
<li>其次四个数的加和可以超过i32的最大值</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}

impl Solution {
    pub fn four_sum(mut v: Vec&lt;i32&gt;, t: i32) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; {
        v.sort();
        let n = v.len();
        let mut res = vec![];
        if n &lt; 4 { return res }
        for i in 0..n-3 {
            if i &gt; 0 &amp;&amp; v[i] == v[i-1] { continue }
            for l in (i+3..n).rev() {
                if l &lt; n - 1 &amp;&amp; v[l] == v[l+1] { continue }
                let mut j = i + 1;
                let mut k = l - 1;
                while j &lt; k {
                    if v[i] as isize + v[j] as isize + v[k] as isize + v[l] as isize == t as isize {
                        res.push(vec![v[i], v[j], v[k], v[l]]);
                        j += 1;
                        while j &lt; k &amp;&amp; v[j] == v[j-1] { j += 1 }
                        k -= 1;
                        while j &lt; k &amp;&amp; v[k] == v[k+1] { k -= 1 }
                    } else if (v[i] as isize + v[j] as isize + v[k] as isize + v[l] as isize) &lt; t as isize {
                        j += 1;
                    } else {
                        k -= 1;
                    }
                }
            }
        }
        res
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-19"><a class="header" href="#学习感想-19">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第四章-字符串part01"><a class="header" href="#第四章-字符串part01">第四章 字符串part01</a></h1>
<p>今日任务 </p>
<p>● 344.反转字符串
● 541. 反转字符串II
● 剑指Offer 05.替换空格
● 151.翻转字符串里的单词
● 剑指Offer58-II.左旋转字符串</p>
<p>详细布置 </p>
<h2 id="344反转字符串"><a class="header" href="#344反转字符串">344.反转字符串</a></h2>
<p>建议： 本题是字符串基础题目，就是考察 reverse 函数的实现，同时也明确一下 平时刷题什么时候用 库函数，什么时候 不用库函数 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html</p>
<h2 id="541-反转字符串ii"><a class="header" href="#541-反转字符串ii">541. 反转字符串II</a></h2>
<p>建议：本题又进阶了，自己先去独立做一做，然后在看题解，对代码技巧会有很深的体会。 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html</p>
<h2 id="剑指offer-05替换空格"><a class="header" href="#剑指offer-05替换空格">剑指Offer 05.替换空格</a></h2>
<p>建议：对于线性数据结构，填充或者删除，后序处理会高效的多。好好体会一下。
题目链接/文章讲解：https://programmercarl.com/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html</p>
<h2 id="151翻转字符串里的单词"><a class="header" href="#151翻转字符串里的单词">151.翻转字符串里的单词</a></h2>
<p>建议：这道题目基本把 刚刚做过的字符串操作 都覆盖了，不过就算知道解题思路，本题代码并不容易写，要多练一练。 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html</p>
<h2 id="剑指offer58-ii左旋转字符串"><a class="header" href="#剑指offer58-ii左旋转字符串">剑指Offer58-II.左旋转字符串</a></h2>
<p>建议：题解中的解法如果没接触过的话，应该会想不到</p>
<p>题目链接/文章讲解：https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="344-反转字符串"><a class="header" href="#344-反转字符串">344. 反转字符串</a></h1>
<h2 id="题目描述-20"><a class="header" href="#题目描述-20">题目描述</a></h2>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<h2 id="解题思路-20"><a class="header" href="#解题思路-20">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}
impl Solution {
    pub fn reverse_string(s: &amp;mut Vec&lt;char&gt;) {
        let n = s.len();
        for i in 0..n/2 {
            let tmp = s[i];
            s[i] = s[n-1-i];
            s[n-1-i] = tmp;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-20"><a class="header" href="#学习感想-20">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="541-反转字符串-ii"><a class="header" href="#541-反转字符串-ii">541. 反转字符串 II</a></h1>
<h2 id="题目描述-21"><a class="header" href="#题目描述-21">题目描述</a></h2>
<p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<h2 id="解题思路-21"><a class="header" href="#解题思路-21">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}
impl Solution {
    pub fn reverse_str(s: String, k: i32) -&gt; String {
        let s = s.chars().collect::&lt;Vec&lt;char&gt;&gt;();
        let mut v: Vec&lt;char&gt; = vec![];
        let mut rev = true;
        for i in s.chunks(k as usize) {
            if rev {
                v.extend(i.iter().rev());
            } else {
                v.extend(i);
            }
            rev = !rev;
        }
        v.iter().collect()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>type system好优雅，真的优雅，真的好优雅，</p>
<p>slice是实现<code>std::iter::DoubleEndedIterator</code>的，所以可以reverse，iter返回的不是不同的迭代器而是<code>std::slice::Iter</code></p>
<p>Vec是实现<code>Extend</code> trait的，所以可以用slice的<code>copy_from_slice</code>实现extend</p>
<h2 id="学习感想-21"><a class="header" href="#学习感想-21">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="剑指-offer-05-替换空格"><a class="header" href="#剑指-offer-05-替换空格">剑指 Offer 05. 替换空格</a></h1>
<h2 id="题目描述-22"><a class="header" href="#题目描述-22">题目描述</a></h2>
<p>请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</p>
<h2 id="解题思路-22"><a class="header" href="#解题思路-22">解题思路</a></h2>
<p>一开始没有想到用双指针</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Solution {}
impl Solution {
    pub fn replace_space(s: String) -&gt; String {
        let mut s = s.chars().collect::&lt;Vec&lt;char&gt;&gt;();
        let cnt = s.iter().filter(|&amp;&amp;x| x == ' ').count();
        let n = s.len();
        s.resize(n + 2 * cnt, ' ');
        let mut tail = s.len() - 1;
        let mut head = n as isize - 1;
        while head &gt;= 0 {
            if s[head as usize] == ' ' {
                s[tail] = '0';
                s[tail - 1] = '2';
                s[tail - 2] = '%';
                tail -= 3;
            } else {
                s[tail] = s[head as usize];
                tail -= 1;
            }
            head -= 1;
        }
        s.iter().collect()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-22"><a class="header" href="#学习感想-22">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="151-反转字符串中的单词"><a class="header" href="#151-反转字符串中的单词">151. 反转字符串中的单词</a></h1>
<h2 id="题目描述-23"><a class="header" href="#题目描述-23">题目描述</a></h2>
<p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<h2 id="解题思路-23"><a class="header" href="#解题思路-23">解题思路</a></h2>
<p>不能用库函数自己写的话还是有点烦，但是不难</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}

impl Solution {
    // O(1) space O(n) time
    pub fn reverse_words(s: String) -&gt; String {
        let mut v: Vec&lt;char&gt; = vec![];
        for c in s.chars().rev() {
            if c == ' ' {
                let a = v.last();
                if a.is_none() { continue }
                if *a.unwrap() == ' ' { continue }
            }
            v.push(c);
        }
        if v[v.len() - 1] == ' ' { v.pop(); }
        // reverse each word
        let mut start = 0;
        while start &lt; v.len() {
            let mut end = start + 1;
            while end &lt; v.len() &amp;&amp; v[end] != ' ' { end += 1 }
            Self::reverse(&amp;mut v[start..end]);
            start = end + 1;
        }
        v.iter().collect()
    }

    pub fn reverse(s: &amp;mut [char]) {
        let n = s.len();
        for i in 0..n/2 {
            let tmp = s[i];
            s[i] = s[n-1-i];
            s[n-1-i] = tmp;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-23"><a class="header" href="#学习感想-23">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="剑指-offer-58---ii-左旋转字符串"><a class="header" href="#剑指-offer-58---ii-左旋转字符串">剑指 Offer 58 - II. 左旋转字符串</a></h1>
<h2 id="题目描述-24"><a class="header" href="#题目描述-24">题目描述</a></h2>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>
<h2 id="解题思路-24"><a class="header" href="#解题思路-24">解题思路</a></h2>
<p>想不到的思路</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}

impl Solution {
    pub fn reverse_left_words(s: String, n: i32) -&gt; String {
        let mut v: Vec&lt;char&gt; = s.chars().collect();
        Self::reverse2(&amp;mut v[..n as usize]);
        Self::reverse2(&amp;mut v[n as usize..]);
        Self::reverse2(&amp;mut v[..]);
        v.iter().collect()
    }
    
    pub fn reverse2(s: &amp;mut [char]) {
        let n = s.len();
        for i in 0..n/2 {
            let tmp = s[i];
            s[i] = s[n-1-i];
            s[n-1-i] = tmp;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-24"><a class="header" href="#学习感想-24">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第四章-字符串part02"><a class="header" href="#第四章-字符串part02">第四章 字符串part02</a></h1>
<p>今日任务 </p>
<p>●28. 实现 strStr()
●459.重复的子字符串
●字符串总结 
●双指针回顾 </p>
<p>详细布置 </p>
<h2 id="28-实现-strstr--本题可以跳过"><a class="header" href="#28-实现-strstr--本题可以跳过">28. 实现 strStr()  （本题可以跳过）</a></h2>
<p>因为KMP算法很难，大家别奢求 一次就把kmp全理解了，大家刚学KMP一定会有各种各样的疑问，先留着，别期望立刻啃明白，第一遍了解大概思路，二刷的时候，再看KMP会 好懂很多。</p>
<p>或者说大家可以放弃一刷可以不看KMP，今天来回顾一下之前的算法题目就可以。</p>
<p>因为大家 算法能力还没到，细扣 很难的算法，会把自己绕进去，就算别人给解释，只会激发出更多的问题和疑惑。所以大家先了解大体过程，知道这么回事， 等自己有 算法基础和思维了，在看多看几遍视频，慢慢就理解了。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html </p>
<h2 id="459重复的子字符串--本题可以跳过"><a class="header" href="#459重复的子字符串--本题可以跳过">459.重复的子字符串  （本题可以跳过）</a></h2>
<p>本题算是KMP算法的一个应用，不过 对KMP了解不够熟练的话，理解本题就难很多。 
我的建议是 KMP和本题，一刷的时候 ，可以适当放过，了解怎么回事就行，二刷的时候再来硬啃</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html </p>
<h2 id="字符串总结"><a class="header" href="#字符串总结">字符串总结</a></h2>
<p>比较简单，大家读一遍就行 </p>
<p>题目链接/文章讲解：https://programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html </p>
<h2 id="双指针回顾"><a class="header" href="#双指针回顾">双指针回顾</a></h2>
<p>此时我们已经做过10到双指针的题目了，来一起回顾一下，大家自己也总结一下双指针的心得 </p>
<p>文章讲解：https://programmercarl.com/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93.html </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="28-找出字符串中第一个匹配项的下标"><a class="header" href="#28-找出字符串中第一个匹配项的下标">28. 找出字符串中第一个匹配项的下标</a></h1>
<h2 id="题目描述-25"><a class="header" href="#题目描述-25">题目描述</a></h2>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
<h2 id="解题思路-25"><a class="header" href="#解题思路-25">解题思路</a></h2>
<p>KMP 对我来说太烧脑了，不得不写点笔记</p>
<p>KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了</p>
<p>前缀是指<strong>不包含最后一个字符</strong>的所有<strong>以第一个字符开头</strong>的连续子串。</p>
<p>后缀是指<strong>不包含第一个字符</strong>的所有<strong>以最后一个字符结尾</strong>的连续子串。</p>
<p>因为前缀表要求的就是相同前后缀的长度</p>
<p>定义两个指针i和j</p>
<ul>
<li>j指向前缀末尾位置(不包含)</li>
<li>i指向后缀末尾位置(包含)</li>
</ul>
<p>next[i] 表示 i（<strong>包括i</strong>）之前最长相等的前后缀长度（其实就是j）</p>
<pre><code class="language-cpp">void getNext(int* next, const string&amp; s){
    int j = -1;
    next[0] = j;
    for(int i = 1; i &lt; s.size(); i++) { // 对当前字符串，j指向上一个字符串的最大前后缀的位置
        while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j ++ ;
        }
        next[i] = j; // 赋值
    }
}
</code></pre>
<h2 id="举例"><a class="header" href="#举例">举例</a></h2>
<pre><code class="language-plaintext">     j
 aabaabaaf
         i
 012345678
  0 01234
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Solution {}

impl Solution {
    pub fn str_str(haystack: String, needle: String) -&gt; i32 {
        let n = needle.len();
        let mut next = vec![0; n];
        let hay = haystack.chars().collect::&lt;Vec&lt;char&gt;&gt;();
        let s = needle.chars().collect::&lt;Vec&lt;char&gt;&gt;();
        let mut j = 0;
        for i in 1..n {
            while j &gt;= 1 &amp;&amp; s[i] != s[j] {
                j = next[j - 1];
            }
            if s[i] == s[j] {
                j += 1;
            }
            next[i] = j;    // next 表示以i结尾的字符串最大前后缀长度
        }
        // dbg!(&amp;next);
        // build next ok
        if n == 0 { return 0 }
        j = 0;
        for i in 0..hay.len() {
            // dbg!(i, j);
            while j &gt;= 1 &amp;&amp; hay[i] != s[j] {
                j = next[j - 1];
            }
            if hay[i] == s[j] {
                j += 1;
            }
            if j == n {
                return (i + 1 - n) as i32
            }
        }
        -1
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-25"><a class="header" href="#学习感想-25">学习感想</a></h2>
<p>还得学习复习</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="459-重复的子字符串"><a class="header" href="#459-重复的子字符串">459. 重复的子字符串</a></h1>
<h2 id="题目描述-26"><a class="header" href="#题目描述-26">题目描述</a></h2>
<p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p>
<h2 id="解题思路-26"><a class="header" href="#解题思路-26">解题思路</a></h2>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<pre><code class="language-plaintext">abcabcabcabc
000123456789

abaaba
001123

abacabacabac
001012345678

abac
0010
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Solution {}

impl Solution {
    pub fn repeated_substring_pattern(s: String) -&gt; bool {
        let n = s.len();
        let mut next = vec![0; n];
        let s = s.chars().collect::&lt;Vec&lt;char&gt;&gt;();
        let mut j = 0;
        for i in 1..n {
            while j &gt;= 1 &amp;&amp; s[i] != s[j] {
                j = next[j - 1];
            }
            if s[i] == s[j] {
                j += 1;
            }
            next[i] = j;    // next 表示以i结尾的字符串最大前后缀长度
        }
        let a = *next.last().unwrap();
        if a == 0 { return false }
        let b = n - a;
        if n % b != 0 { return false }
        else { true }
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-26"><a class="header" href="#学习感想-26">学习感想</a></h2>
<p>什么时候该用KMP很懵</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第五章-栈与队列part01"><a class="header" href="#第五章-栈与队列part01">第五章 栈与队列part01</a></h1>
<p>今日任务：
● 理论基础
● 232.用栈实现队列
● 225. 用队列实现栈
理论基础 </p>
<p>了解一下 栈与队列的内部实现机智，文中是以C++为例讲解的。 </p>
<p>文章讲解：https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</p>
<h2 id="232用栈实现队列"><a class="header" href="#232用栈实现队列">232.用栈实现队列</a></h2>
<p>大家可以先看视频，了解一下模拟的过程，然后写代码会轻松很多。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html</p>
<h2 id="225-用队列实现栈"><a class="header" href="#225-用队列实现栈">225. 用队列实现栈</a></h2>
<p>可以大家惯性思维，以为还要两个队列来模拟栈，其实只用一个队列就可以模拟栈了。 </p>
<p>建议大家掌握一个队列的方法，更简单一些，可以先看视频讲解</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="232-用栈实现队列"><a class="header" href="#232-用栈实现队列">232. 用栈实现队列</a></h1>
<h2 id="题目描述-27"><a class="header" href="#题目描述-27">题目描述</a></h2>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：</p>
<p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<h2 id="解题思路-27"><a class="header" href="#解题思路-27">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>

<span class="boring">fn main() {
</span>struct MyQueue {
    is: Vec&lt;i32&gt;,
    os: Vec&lt;i32&gt;,
}


/**
 * `&amp;self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&amp;mut self` instead.
 */
impl MyQueue {

    fn new() -&gt; Self {
        Self { is: vec![], os: vec![] }
    }

    fn o2i(&amp;mut self) {
        while let Some(i) = self.os.pop() {
            self.is.push(i);
        }
    }

    fn i2o(&amp;mut self) {
        while let Some(i) = self.is.pop() {
            self.os.push(i);
        }
    }
    
    fn push(&amp;mut self, x: i32) {
        self.o2i();
        self.is.push(x);
    }
    
    fn pop(&amp;mut self) -&gt; i32 {
        self.i2o();
        self.os.pop().unwrap()
    }
    
    fn peek(&amp;mut self) -&gt; i32 {
        self.i2o();
        self.os.last().copied().unwrap()
    }
    
    fn empty(&amp;self) -&gt; bool {
        self.is.is_empty() &amp;&amp; self.os.is_empty()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-27"><a class="header" href="#学习感想-27">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="225-用队列实现栈-1"><a class="header" href="#225-用队列实现栈-1">225. 用队列实现栈</a></h1>
<h2 id="题目描述-28"><a class="header" href="#题目描述-28">题目描述</a></h2>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<h2 id="解题思路-28"><a class="header" href="#解题思路-28">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct MyStack {
    q: std::collections::VecDeque&lt;i32&gt;,
}


/**
 * `&amp;self` means the method takes an immutable reference.
 * If you need a mutable reference, change it to `&amp;mut self` instead.
 */
impl MyStack {

    fn new() -&gt; Self {
        Self { q: std::collections::VecDeque::new() }
    }
    
    fn push(&amp;mut self, x: i32) {
        self.q.push_back(x);
    }
    
    fn pop(&amp;mut self) -&gt; i32 {
        let n = self.q.len();
        for _ in 1..n {
            let x = self.q.pop_front().unwrap();
            self.q.push_back(x);
        }
        self.q.pop_front().unwrap()
    }
    
    fn top(&amp;mut self) -&gt; i32 {
        let n = self.q.len();
        for _ in 1..n {
            let x = self.q.pop_front().unwrap();
            self.q.push_back(x);
        }
        let x = self.q.pop_front().unwrap();
        self.q.push_back(x);
        return x;
    }
    
    fn empty(&amp;self) -&gt; bool {
        self.q.is_empty()
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-28"><a class="header" href="#学习感想-28">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第五章-栈与队列part02"><a class="header" href="#第五章-栈与队列part02">第五章 栈与队列part02</a></h1>
<p>今日内容： </p>
<p>● 20. 有效的括号
● 1047. 删除字符串中的所有相邻重复项
● 150. 逆波兰表达式求值</p>
<p>详细布置 </p>
<h2 id="20-有效的括号"><a class="header" href="#20-有效的括号">20. 有效的括号</a></h2>
<p>讲完了栈实现队列，队列实现栈，接下来就是栈的经典应用了。 </p>
<p>大家先自己思考一下 有哪些不匹配的场景，在看视频 我讲的都有哪些场景，落实到代码其实就容易很多了。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html</p>
<h2 id="1047-删除字符串中的所有相邻重复项"><a class="header" href="#1047-删除字符串中的所有相邻重复项">1047. 删除字符串中的所有相邻重复项</a></h2>
<p>栈的经典应用。 </p>
<p>要知道栈为什么适合做这种类似于爱消除的操作，因为栈帮助我们记录了 遍历数组当前元素时候，前一个元素是什么。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html</p>
<h2 id="150-逆波兰表达式求值"><a class="header" href="#150-逆波兰表达式求值">150. 逆波兰表达式求值</a></h2>
<p>本题不难，但第一次做的话，会很难想到，所以先看视频，了解思路再去做题 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20-有效的括号-1"><a class="header" href="#20-有效的括号-1">20. 有效的括号</a></h1>
<h2 id="题目描述-29"><a class="header" href="#题目描述-29">题目描述</a></h2>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。</p>
<h2 id="解题思路-29"><a class="header" href="#解题思路-29">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Solution {}

impl Solution {
    pub fn is_valid(s: String) -&gt; bool {
        let mut v = vec![]; // only }])
        for c in s.chars() {
            if c == '(' || c == '[' || c == '{' {
                v.push(Self::mutate(c));
            } else {
                if let Some(&amp;x) = v.last() {
                    if x == c { v.pop(); }
                    else { return false }
                } else {
                    return false
                }
            }
        }
        v.is_empty()
    }
    fn mutate(x: char) -&gt; char {
        if x == '(' { return ')' }
        else if x == '[' { return ']' }
        else {return '}'}
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-29"><a class="header" href="#学习感想-29">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1047-删除字符串中的所有相邻重复项-1"><a class="header" href="#1047-删除字符串中的所有相邻重复项-1">1047. 删除字符串中的所有相邻重复项</a></h1>
<h2 id="题目描述-30"><a class="header" href="#题目描述-30">题目描述</a></h2>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<h2 id="解题思路-30"><a class="header" href="#解题思路-30">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Solution {}

impl Solution {
    pub fn remove_duplicates(s: String) -&gt; String {
        let mut v = vec![];
        for c in s.chars() {
            if let Some(&amp;x) = v.last() {
                if x == c { v.pop(); }
                else { v.push(c) }
            } else { v.push(c) }
        }
        v.iter().collect()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-30"><a class="header" href="#学习感想-30">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="150-逆波兰表达式求值-1"><a class="header" href="#150-逆波兰表达式求值-1">150. 逆波兰表达式求值</a></h1>
<h2 id="题目描述-31"><a class="header" href="#题目描述-31">题目描述</a></h2>
<p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p>注意：</p>
<p>有效的算符为 '+'、'-'、'*' 和 '/' 。
每个操作数（运算对象）都可以是一个整数或者另一个表达式。
两个整数之间的除法总是 向零截断 。
表达式中不含除零运算。
输入是一个根据逆波兰表示法表示的算术表达式。
答案及所有中间计算结果可以用 32 位 整数表示</p>
<h2 id="解题思路-31"><a class="header" href="#解题思路-31">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Solution {}
impl Solution {
    pub fn eval_rpn(tokens: Vec&lt;String&gt;) -&gt; i32 {
        let mut v = vec![];
        for s in tokens {
            let a = vec![&quot;+&quot;,&quot;-&quot;,&quot;*&quot;,&quot;/&quot;];
            if a.contains(&amp;&amp;s[..]) {
                let x = v.pop().unwrap();
                let y = v.pop().unwrap();
                match &amp;s[..] {
                    &quot;+&quot; =&gt; {v.push(x+y)},
                    &quot;-&quot; =&gt; {v.push(y-x)},
                    &quot;*&quot; =&gt; {v.push(y*x)},
                    &quot;/&quot; =&gt; {v.push(y/x)},
                    _ =&gt; {},
                }
            } else {
                v.push(s.parse::&lt;i32&gt;().unwrap());
            }
        }
        v.pop().unwrap()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-31"><a class="header" href="#学习感想-31">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="休息日-1"><a class="header" href="#休息日-1">休息日</a></h1>
<p>小红书笔试薄砂我</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第五章-栈与队列part03"><a class="header" href="#第五章-栈与队列part03">第五章 栈与队列part03</a></h1>
<p>今日内容： </p>
<p>● 239. 滑动窗口最大值
● 347.前 K 个高频元素
● 总结</p>
<p>详细布置 </p>
<h2 id="239-滑动窗口最大值-一刷至少需要理解思路"><a class="header" href="#239-滑动窗口最大值-一刷至少需要理解思路">239. 滑动窗口最大值 （一刷至少需要理解思路）</a></h2>
<p>之前讲的都是栈的应用，这次该是队列的应用了。</p>
<p>本题算比较有难度的，需要自己去构造单调队列，建议先看视频来理解。 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html </p>
<h2 id="347前-k-个高频元素--一刷至少需要理解思路"><a class="header" href="#347前-k-个高频元素--一刷至少需要理解思路">347.前 K 个高频元素  （一刷至少需要理解思路）</a></h2>
<p>大/小顶堆的应用， 在C++中就是优先级队列 </p>
<p>本题是 大数据中取前k值 的经典思路，了解想法之后，不算难。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>栈与队列做一个总结吧，加油</p>
<p>https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="239-滑动窗口最大值"><a class="header" href="#239-滑动窗口最大值">239. 滑动窗口最大值</a></h1>
<h2 id="题目描述-32"><a class="header" href="#题目描述-32">题目描述</a></h2>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 。</p>
<h2 id="解题思路-32"><a class="header" href="#解题思路-32">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Solution {}
impl Solution {
    pub fn max_sliding_window(v: Vec&lt;i32&gt;, k: i32) -&gt; Vec&lt;i32&gt; {
        let k = k as usize;
        let n = v.len();
        let mut res = vec![];
        let mut q = std::collections::VecDeque::new();
        for i in 0..n {
            if i &gt;= k &amp;&amp; v[i - k] == q[0] {
                q.pop_front();
            }
            // add last
            while let Some(&amp;x) = q.back() {
                if x &lt; v[i] { q.pop_back(); }
                else { break }
            }
            q.push_back(v[i]);
            if i &gt;= k - 1 {
                res.push(q[0]);
            }
        }
        res
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-32"><a class="header" href="#学习感想-32">学习感想</a></h2>
<p>一开始确实以为大顶堆就行了，其实要用单调栈，之前也有做过单调栈的题目</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="347-前-k-个高频元素"><a class="header" href="#347-前-k-个高频元素">347. 前 K 个高频元素</a></h1>
<h2 id="题目描述-33"><a class="header" href="#题目描述-33">题目描述</a></h2>
<p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
<h2 id="解题思路-33"><a class="header" href="#解题思路-33">解题思路</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Solution {}
#[derive(PartialEq, Eq)]
struct Y { a: i32, b: usize, }
type Z = Y;
use std::cmp::Ordering;
impl PartialOrd&lt;Z&gt;for Z{fn partial_cmp(&amp;self,o:&amp;Z)-&gt;Option&lt;Ordering&gt;{Some(self.cmp(o))}}
impl Ord for Z{fn cmp(&amp;self,o:&amp;Z)-&gt;Ordering{o.b.cmp(&amp;self.b)}}
impl Solution {
    pub fn top_k_frequent(v: Vec&lt;i32&gt;, k: i32) -&gt; Vec&lt;i32&gt; {
        use std::collections::HashMap;
        use std::collections::BinaryHeap;
        let mut m: HashMap&lt;i32, usize&gt; = HashMap::new();
        let mut q: BinaryHeap&lt;Z&gt; = BinaryHeap::new();
        for i in v {
            *m.entry(i).or_default() += 1;
        }
        for (a, b) in m {
            q.push(Z {a:a, b:b});
            if q.len() &gt; k as usize { q.pop(); }
        }
        let mut res = vec![];
        for i in q {
            res.push(i.a);
        }
        res
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="学习感想-33"><a class="header" href="#学习感想-33">学习感想</a></h2>
<p>map+小顶堆</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第六章-二叉树part01"><a class="header" href="#第六章-二叉树part01">第六章 二叉树part01</a></h1>
<p>今日内容： </p>
<p>● 理论基础
● 递归遍历<br />
● 迭代遍历
● 统一迭代</p>
<p>详细布置 </p>
<h2 id="理论基础"><a class="header" href="#理论基础">理论基础</a></h2>
<p>需要了解 二叉树的种类，存储方式，遍历方式 以及二叉树的定义 </p>
<p>文章讲解：https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</p>
<h2 id="递归遍历-必须掌握"><a class="header" href="#递归遍历-必须掌握">递归遍历 （必须掌握）</a></h2>
<p>二叉树的三种递归遍历掌握其规律后，其实很简单 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html</p>
<h2 id="迭代遍历-基础不好的录友迭代法可以放过"><a class="header" href="#迭代遍历-基础不好的录友迭代法可以放过">迭代遍历 （基础不好的录友，迭代法可以放过）</a></h2>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html</p>
<h2 id="统一迭代---基础不好的录友迭代法可以放过"><a class="header" href="#统一迭代---基础不好的录友迭代法可以放过">统一迭代   （基础不好的录友，迭代法可以放过）</a></h2>
<p>这是统一迭代法的写法， 如果学有余力，可以掌握一下</p>
<p>题目链接/文章讲解：https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="144-二叉树的前序遍历"><a class="header" href="#144-二叉树的前序遍历">144. 二叉树的前序遍历</a></h1>
<h2 id="题目描述-34"><a class="header" href="#题目描述-34">题目描述</a></h2>
<h2 id="解题思路-34"><a class="header" href="#解题思路-34">解题思路</a></h2>
<pre><code class="language-cpp">
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res ;
        traverse(root, res);
        return res ;
    }

    void traverse(TreeNode* root, vector&lt;int&gt;&amp; vec) {
        if (root == NULL) return ;
        vec.push_back(root-&gt;val);
        traverse(root-&gt;left, vec);
        traverse(root-&gt;right, vec);
    }
};

</code></pre>
<p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</p>
<p>递归的实质就是迭代</p>
<p>统一格式法</p>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res ;
        vector&lt;TreeNode *&gt; s ;
        if (root != NULL) s.push_back(root);
        while (!s.empty()) {
            TreeNode* last = s.back();
            s.pop_back();
            if (last == NULL) {
                TreeNode* last = s.back();
                s.pop_back();
                res.push_back(last-&gt;val);
            } else {
                s.push_back(last);
                s.push_back(NULL);
                if (last-&gt;right) s.push_back(last-&gt;right);
                if (last-&gt;left) s.push_back(last-&gt;left);
            }
        }
        return res ;
    }
};
</code></pre>
<h2 id="学习感想-34"><a class="header" href="#学习感想-34">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第六章--二叉树-part02"><a class="header" href="#第六章--二叉树-part02">第六章  二叉树 part02</a></h1>
<p>今日内容： </p>
<p>● 层序遍历  10 
● 226.翻转二叉树 
● 101.对称二叉树 2</p>
<p>详细布置 </p>
<h2 id="层序遍历"><a class="header" href="#层序遍历">层序遍历</a></h2>
<p>看完本篇可以一口气刷十道题，试一试， 层序遍历并不难，大家可以很快刷了十道题。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html</p>
<h2 id="226翻转二叉树-优先掌握递归"><a class="header" href="#226翻转二叉树-优先掌握递归">226.翻转二叉树 （优先掌握递归）</a></h2>
<p>这道题目 一些做过的同学 理解的也不够深入，建议大家先看我的视频讲解，无论做过没做过，都会有很大收获。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html </p>
<h2 id="101-对称二叉树-优先掌握递归"><a class="header" href="#101-对称二叉树-优先掌握递归">101. 对称二叉树 （优先掌握递归）</a></h2>
<p>先看视频讲解，会更容易一些。 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="102-二叉树的层序遍历"><a class="header" href="#102-二叉树的层序遍历">102. 二叉树的层序遍历</a></h1>
<h2 id="题目描述-35"><a class="header" href="#题目描述-35">题目描述</a></h2>
<p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<h2 id="解题思路-35"><a class="header" href="#解题思路-35">解题思路</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt;  res ; 
        if (root == NULL) return res ;
        deque&lt;TreeNode*&gt; v;
        v.push_back(root);
        while (!v.empty()) {
            int size = v.size();
            vector&lt;int&gt; level_res ;
            for (int i = 0; i &lt; size; i ++) {
                TreeNode * ptr = v.front();
                v.pop_front();
                level_res.push_back(ptr-&gt;val);
                if (ptr-&gt;left) v.push_back(ptr-&gt;left);
                if (ptr-&gt;right) v.push_back(ptr-&gt;right);
            }
            res.push_back(level_res) ;
        }
        return res;
    }
};
</code></pre>
<h2 id="学习感想-35"><a class="header" href="#学习感想-35">学习感想</a></h2>
<h3 id="107-二叉树的层序遍历-ii"><a class="header" href="#107-二叉树的层序遍历-ii">107. 二叉树的层序遍历 II</a></h3>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt;  res ; 
        if (root == NULL) return res ;
        deque&lt;TreeNode*&gt; v;
        v.push_back(root);
        while (!v.empty()) {
            int size = v.size();
            vector&lt;int&gt; level_res ;
            for (int i = 0; i &lt; size; i ++) {
                TreeNode * ptr = v.front();
                v.pop_front();
                level_res.push_back(ptr-&gt;val);
                if (ptr-&gt;left) v.push_back(ptr-&gt;left);
                if (ptr-&gt;right) v.push_back(ptr-&gt;right);
            }
            res.push_back(level_res) ;
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
</code></pre>
<h3 id="199-二叉树的右视图"><a class="header" href="#199-二叉树的右视图">199. 二叉树的右视图</a></h3>
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt; res ; 
        if (root == NULL) return res ;
        deque&lt;TreeNode*&gt; v;
        v.push_back(root);
        while (!v.empty()) {
            int size = v.size();
            vector&lt;int&gt; level_res ;
            for (int i = 0; i &lt; size; i ++) {
                TreeNode * ptr = v.front();
                v.pop_front();
                level_res.push_back(ptr-&gt;val);
                if (ptr-&gt;left) v.push_back(ptr-&gt;left);
                if (ptr-&gt;right) v.push_back(ptr-&gt;right);
            }
            res.push_back(level_res.back());
        }
        return res;
    }
};
</code></pre>
<h3 id="637-二叉树的层平均值"><a class="header" href="#637-二叉树的层平均值">637. 二叉树的层平均值</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="226-翻转二叉树"><a class="header" href="#226-翻转二叉树">226. 翻转二叉树</a></h1>
<h2 id="题目描述-36"><a class="header" href="#题目描述-36">题目描述</a></h2>
<p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<h2 id="解题思路-36"><a class="header" href="#解题思路-36">解题思路</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        traverse(root);
        return root;
    }
    void traverse(TreeNode* root) {
        if (root == NULL) return ;
        swap(root-&gt;left, root-&gt;right);
        traverse(root-&gt;left);
        traverse(root-&gt;right);
    }
};
</code></pre>
<h2 id="学习感想-36"><a class="header" href="#学习感想-36">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="101-对称二叉树"><a class="header" href="#101-对称二叉树">101. 对称二叉树</a></h1>
<h2 id="题目描述-37"><a class="header" href="#题目描述-37">题目描述</a></h2>
<h2 id="解题思路-37"><a class="header" href="#解题思路-37">解题思路</a></h2>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def f(self,a,b):
        if a == None and b != None:
            return False
        elif a == None and b == None:
            return True
        elif a != None and b == None:
            return False
        else:
            if a.val != b.val:
                return False
            else:
                res1 = self.f(a.left, b.right)
                res2 = self.f(a.right, b.left)
                return res1 and res2
    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:
        if root == None:
            return True
        else:
            return self.f(root.left, root.right)
</code></pre>
<h2 id="学习感想-37"><a class="header" href="#学习感想-37">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第六章--二叉树part03"><a class="header" href="#第六章--二叉树part03">第六章  二叉树part03</a></h1>
<p>今日内容： </p>
<p>● 104.二叉树的最大深度  559.n叉树的最大深度
● 111.二叉树的最小深度
● 222.完全二叉树的节点个数</p>
<p>迭代法，大家可以直接过，二刷有精力的时候 再去掌握迭代法。</p>
<p>详细布置 </p>
<h2 id="104二叉树的最大深度-优先掌握递归"><a class="header" href="#104二叉树的最大深度-优先掌握递归">104.二叉树的最大深度 （优先掌握递归）</a></h2>
<p>什么是深度，什么是高度，如何求深度，如何求高度，这里有关系到二叉树的遍历方式。</p>
<p>大家 要先看视频讲解，就知道以上我说的内容了，很多录友刷过这道题，但理解的还不够。</p>
<p>题目链接/文章讲解/视频讲解： https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html</p>
<h2 id="111二叉树的最小深度-优先掌握递归"><a class="header" href="#111二叉树的最小深度-优先掌握递归">111.二叉树的最小深度 （优先掌握递归）</a></h2>
<p>先看视频讲解，和最大深度 看似差不多，其实 差距还挺大，有坑。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html </p>
<h2 id="222完全二叉树的节点个数优先掌握递归"><a class="header" href="#222完全二叉树的节点个数优先掌握递归">222.完全二叉树的节点个数（优先掌握递归）</a></h2>
<p>需要了解，普通二叉树 怎么求，完全二叉树又怎么求</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="104-二叉树的最大深度"><a class="header" href="#104-二叉树的最大深度">104. 二叉树的最大深度</a></h1>
<h2 id="题目描述-38"><a class="header" href="#题目描述-38">题目描述</a></h2>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：
给定二叉树 [3,9,20,null,null,15,7]，</p>
<h2 id="解题思路-38"><a class="header" href="#解题思路-38">解题思路</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        else {
            int l = maxDepth(root-&gt;left);
            int r = maxDepth(root-&gt;right);
            int m = max(l, r);
            return m + 1;
        }
    }
};
</code></pre>
<h2 id="学习感想-38"><a class="header" href="#学习感想-38">学习感想</a></h2>
<p>递归</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="111-二叉树的最小深度"><a class="header" href="#111-二叉树的最小深度">111. 二叉树的最小深度</a></h1>
<h2 id="题目描述-39"><a class="header" href="#题目描述-39">题目描述</a></h2>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明：叶子节点是指没有子节点的节点。</p>
<h2 id="解题思路-39"><a class="header" href="#解题思路-39">解题思路</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == NULL) return 0;
        if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return 1;
        if (root-&gt;left == NULL) return minDepth(root-&gt;right) + 1;
        if (root-&gt;right == NULL) return minDepth(root-&gt;left) + 1;
        else return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1;
    }
};
</code></pre>
<h2 id="学习感想-39"><a class="header" href="#学习感想-39">学习感想</a></h2>
<p>写到这里我根本没有想明白为什么这个是对的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="222-完全二叉树的节点个数"><a class="header" href="#222-完全二叉树的节点个数">222. 完全二叉树的节点个数</a></h1>
<h2 id="题目描述-40"><a class="header" href="#题目描述-40">题目描述</a></h2>
<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<h2 id="解题思路-40"><a class="header" href="#解题思路-40">解题思路</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == NULL) return 0;
        int leftcnt = 0;
        int rightcnt = 0;
        TreeNode* ptr = root;
        while (ptr -&gt;left != NULL) {
            ptr = ptr-&gt;left;
            leftcnt ++ ;
        }
        ptr = root;
        while (ptr -&gt;right != NULL) {
            ptr = ptr-&gt;right;
            leftcnt ++ ;
        }
        if (leftcnt == rightcnt) {
            return (2 &lt;&lt; leftcnt) - 1;
        }
        else {
            return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;
        }

    }
};
</code></pre>
<h2 id="学习感想-40"><a class="header" href="#学习感想-40">学习感想</a></h2>
<p>时间复杂度为Logn</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第六章---二叉树part04"><a class="header" href="#第六章---二叉树part04">第六章   二叉树part04</a></h1>
<p>今日内容： </p>
<p>● 110.平衡二叉树 
● 257. 二叉树的所有路径 
● 404.左叶子之和 </p>
<p>详细布置 </p>
<p>迭代法，大家可以直接过，二刷有精力的时候 再去掌握迭代法。</p>
<h2 id="110平衡二叉树-优先掌握递归"><a class="header" href="#110平衡二叉树-优先掌握递归">110.平衡二叉树 （优先掌握递归）</a></h2>
<p>再一次涉及到，什么是高度，什么是深度，可以巩固一下。</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html</p>
<h2 id="257-二叉树的所有路径-优先掌握递归"><a class="header" href="#257-二叉树的所有路径-优先掌握递归">257. 二叉树的所有路径 （优先掌握递归）</a></h2>
<p>这是大家第一次接触到回溯的过程， 我在视频里重点讲解了 本题为什么要有回溯，已经回溯的过程。 </p>
<p>如果对回溯 似懂非懂，没关系， 可以先有个印象。 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html </p>
<h2 id="404左叶子之和-优先掌握递归"><a class="header" href="#404左叶子之和-优先掌握递归">404.左叶子之和 （优先掌握递归）</a></h2>
<p>其实本题有点文字游戏，搞清楚什么是左叶子，剩下的就是二叉树的基本操作。 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="110-平衡二叉树"><a class="header" href="#110-平衡二叉树">110. 平衡二叉树</a></h1>
<h2 id="题目描述-41"><a class="header" href="#题目描述-41">题目描述</a></h2>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<h2 id="解题思路-41"><a class="header" href="#解题思路-41">解题思路</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    int f(TreeNode* root) {
        if (root == NULL) return 0;
        int l = f(root-&gt;left);
        if (l == -1) return -1;
        int r = f(root-&gt;right);
        if (r == -1) return -1;
        if (abs(l-r)&gt;1) return -1;
        return max(l,r)+1;
    }

    bool isBalanced(TreeNode* root) {
        return f(root) != -1 ? true : false;
    }
};
</code></pre>
<h2 id="学习感想-41"><a class="header" href="#学习感想-41">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="257-二叉树的所有路径"><a class="header" href="#257-二叉树的所有路径">257. 二叉树的所有路径</a></h1>
<h2 id="题目描述-42"><a class="header" href="#题目描述-42">题目描述</a></h2>
<p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<h2 id="解题思路-42"><a class="header" href="#解题思路-42">解题思路</a></h2>
<pre><code class="language-cpp">class Solution {
    void f(TreeNode* root, string path, vector&lt;string&gt; &amp;res) {
        path += to_string(root-&gt;val);
        if (!root-&gt;left &amp;&amp; !root-&gt;right) {
            res.push_back(path);
            return;
        }
        if(root-&gt;left)f(root-&gt;left,path+&quot;-&gt;&quot;,res);
        if(root-&gt;right)f(root-&gt;right,path+&quot;-&gt;&quot;,res);
    }
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
        vector&lt;string&gt; res;
        string path;
        if (!root) return res;
        f(root, path, res);
        return res;
    }
};
</code></pre>
<h2 id="学习感想-42"><a class="header" href="#学习感想-42">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="404-左叶子之和"><a class="header" href="#404-左叶子之和">404. 左叶子之和</a></h1>
<h2 id="题目描述-43"><a class="header" href="#题目描述-43">题目描述</a></h2>
<p>给定二叉树的根节点 root ，返回所有左叶子之和。</p>
<h2 id="解题思路-43"><a class="header" href="#解题思路-43">解题思路</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == NULL) return 0;
        int r=0;
        if (root-&gt;left!=NULL&amp;&amp;root-&gt;left-&gt;left==NULL&amp;&amp;root-&gt;left-&gt;right==NULL)r+=root-&gt;left-&gt;val;
        return r+sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right);
    }
};
</code></pre>
<h2 id="学习感想-43"><a class="header" href="#学习感想-43">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第六章-二叉树-part05"><a class="header" href="#第六章-二叉树-part05">第六章 二叉树 part05</a></h1>
<p>今日内容 </p>
<p>● 513.找树左下角的值
● 112. 路径总和  113.路径总和ii
● 106.从中序与后序遍历序列构造二叉树 105.从前序与中序遍历序列构造二叉树</p>
<p>详细布置 </p>
<h2 id="找树左下角的值"><a class="header" href="#找树左下角的值">找树左下角的值</a></h2>
<p>本地递归偏难，反而迭代简单属于模板题， 两种方法掌握一下 </p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html</p>
<h2 id="路径总和"><a class="header" href="#路径总和">路径总和</a></h2>
<p>本题 又一次设计要回溯的过程，而且回溯的过程隐藏的还挺深，建议先看视频来理解 </p>
<ol start="112">
<li>路径总和，和 113. 路径总和ii 一起做了。 优先掌握递归法。</li>
</ol>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html</p>
<h2 id="从中序与后序遍历序列构造二叉树"><a class="header" href="#从中序与后序遍历序列构造二叉树">从中序与后序遍历序列构造二叉树</a></h2>
<p>本题算是比较难的二叉树题目了，大家先看视频来理解。 </p>
<p>106.从中序与后序遍历序列构造二叉树，105.从前序与中序遍历序列构造二叉树 一起做，思路一样的</p>
<p>题目链接/文章讲解/视频讲解：https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="513-找树左下角的值"><a class="header" href="#513-找树左下角的值">513. 找树左下角的值</a></h1>
<h2 id="题目描述-44"><a class="header" href="#题目描述-44">题目描述</a></h2>
<p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<h2 id="解题思路-44"><a class="header" href="#解题思路-44">解题思路</a></h2>
<p>迭代法简单</p>
<pre><code class="language-cpp">class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        deque&lt;TreeNode* &gt; v;
        int res=0;
        v.push_back(root);
        while (!v.empty()) {
            res=v.front()-&gt;val;
            int n = v.size();
            for (int i = 0; i &lt; n;i++) {
                TreeNode* ptr=v.front();v.pop_front();
                if(ptr-&gt;left)v.push_back(ptr-&gt;left);
                if(ptr-&gt;right)v.push_back(ptr-&gt;right);
            }
        }
        return res;
    }
};
</code></pre>
<p>递归法</p>
<pre><code class="language-cpp">class Solution {
public:
    void f(TreeNode*p,int d,int&amp;res,int&amp;resd) {
        if(!p)return;
        if(d&gt;resd){resd=d;res=p-&gt;val;}
        f(p-&gt;left,d+1,res,resd);
        f(p-&gt;right,d+1,res,resd);
    }
    int findBottomLeftValue(TreeNode*root) {
        int res=0,resd=0;
        f(root,1,res,resd);
        return res;
    }
};
</code></pre>
<h2 id="学习感想-44"><a class="header" href="#学习感想-44">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="112-路径总和"><a class="header" href="#112-路径总和">112. 路径总和</a></h1>
<h2 id="题目描述-45"><a class="header" href="#题目描述-45">题目描述</a></h2>
<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<h2 id="解题思路-45"><a class="header" href="#解题思路-45">解题思路</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    bool hasPathSum(TreeNode*p,int t) {
if(!p)return false;if(!p-&gt;left&amp;&amp;!p-&gt;right)return p-&gt;val==t;return hasPathSum(p-&gt;left,t-p-&gt;val)||hasPathSum(p-&gt;right,t-p-&gt;val);
    }
};
</code></pre>
<h2 id="113-路径总和-ii"><a class="header" href="#113-路径总和-ii">113. 路径总和 II</a></h2>
<h2 id="题目描述-46"><a class="header" href="#题目描述-46">题目描述</a></h2>
<p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<h2 id="解题思路-46"><a class="header" href="#解题思路-46">解题思路</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    void f(vector&lt;int&gt;&amp;path,TreeNode*p,vector&lt;vector&lt;int&gt;&gt;&amp;res,int t){if(!p)return;path.push_back(p-&gt;val);
if(!p-&gt;left&amp;&amp;!p-&gt;right)if(t==p-&gt;val)res.push_back(path);f(path,p-&gt;left,res,t-p-&gt;val);f(path,p-&gt;right,res,t-p-&gt;val);path.pop_back();}
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode*p,int t) {
vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; path;f(path,p,res,t);return res;
    }
};
</code></pre>
<h2 id="学习感想-45"><a class="header" href="#学习感想-45">学习感想</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="106-从中序与后序遍历序列构造二叉树"><a class="header" href="#106-从中序与后序遍历序列构造二叉树">106. 从中序与后序遍历序列构造二叉树</a></h1>
<h2 id="题目描述-47"><a class="header" href="#题目描述-47">题目描述</a></h2>
<p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<h2 id="解题思路-47"><a class="header" href="#解题思路-47">解题思路</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt; ino, vector&lt;int&gt; posto) {
        if(ino.empty())return NULL;
        int l=posto.back();
        auto it=find(ino.begin(),ino.end(),l);
        int i =distance(ino.begin(),it);
        TreeNode*left=buildTree(vector&lt;int&gt;(ino.begin(), it),vector&lt;int&gt;(posto.begin(),posto.begin()+i));
        TreeNode*right=buildTree(vector&lt;int&gt;(it+1,ino.end()),vector&lt;int&gt;(posto.begin()+i,posto.end()-1));
        return new TreeNode(l, left, right);
    }
};
</code></pre>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a class="header" href="#105-从前序与中序遍历序列构造二叉树">105. 从前序与中序遍历序列构造二叉树</a></h2>
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt; preorder, vector&lt;int&gt;ino) {
        if(ino.empty())return NULL;
        int l =preorder.front();
        auto it=find(ino.begin(),ino.end(),l);
        int i =distance(ino.begin(),it);
        TreeNode*left=buildTree(vector&lt;int&gt;(preorder.begin()+1,preorder.begin()+i+1),vector&lt;int&gt;(ino.begin(), it));
        TreeNode*right=buildTree(vector&lt;int&gt;(preorder.begin()+i+1,preorder.end()),vector&lt;int&gt;(it+1,ino.end()));
        return new TreeNode(l,left,right);
    }
};
</code></pre>
<h2 id="学习感想-46"><a class="header" href="#学习感想-46">学习感想</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
